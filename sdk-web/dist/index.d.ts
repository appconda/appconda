// Generated by dts-bundle v0.7.3

type Payload = {
        [key: string]: any;
};
type Headers = {
        [key: string]: string;
};
export type RealtimeResponseEvent<T extends unknown> = {
        events: string[];
        channels: string[];
        timestamp: number;
        payload: T;
};
export type UploadProgress = {
        $id: string;
        progress: number;
        sizeUploaded: number;
        chunksTotal: number;
        chunksUploaded: number;
};
class AppwriteException extends Error {
        code: number;
        response: string;
        type: string;
        constructor(message: string, code?: number, type?: string, response?: string);
}
class Client {
        config: {
                endpoint: string;
                endpointRealtime: string;
                project: string;
                jwt: string;
                locale: string;
                session: string;
        };
        headers: Headers;
        /**
            * Set Endpoint
            *
            * Your project endpoint
            *
            * @param {string} endpoint
            *
            * @returns {this}
            */
        setEndpoint(endpoint: string): this;
        /**
            * Set Realtime Endpoint
            *
            * @param {string} endpointRealtime
            *
            * @returns {this}
            */
        setEndpointRealtime(endpointRealtime: string): this;
        /**
            * Set Project
            *
            * Your project ID
            *
            * @param value string
            *
            * @return {this}
            */
        setProject(value: string): this;
        /**
            * Set JWT
            *
            * Your secret JSON Web Token
            *
            * @param value string
            *
            * @return {this}
            */
        setJWT(value: string): this;
        /**
            * Set Locale
            *
            * @param value string
            *
            * @return {this}
            */
        setLocale(value: string): this;
        /**
            * Set Session
            *
            * The user session to authenticate with
            *
            * @param value string
            *
            * @return {this}
            */
        setSession(value: string): this;
        /**
            * Subscribes to Appconda events and passes you the payload in realtime.
            *
            * @param {string|string[]} channels
            * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.
            *
            * Possible channels are:
            * - account
            * - collections
            * - collections.[ID]
            * - collections.[ID].documents
            * - documents
            * - documents.[ID]
            * - files
            * - files.[ID]
            * - executions
            * - executions.[ID]
            * - functions.[ID]
            * - teams
            * - teams.[ID]
            * - memberships
            * - memberships.[ID]
            * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.
            * @returns {() => void} Unsubscribes from events.
            */
        subscribe<T extends unknown>(channels: string | string[], callback: (payload: RealtimeResponseEvent<T>) => void): () => void;
        call(method: string, url: URL, headers?: Headers, params?: Payload): Promise<any>;
}
export { Client, AppwriteException };
export type { Models, Payload };

export class Account extends Service {
        constructor(client: Client);
        /**
            * Get account
            *
            * Get the currently logged in user.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        get<Preferences extends Models.Preferences>(): Promise<Models.User<Preferences>>;
        /**
            * Create account
            *
            * Use this endpoint to allow a new user to register a new account in your
            * project. After the user registration completes successfully, you can use
            * the
            * [/account/verfication](https://appconda.io/docs/references/cloud/client-web/account#createVerification)
            * route to start verifying the user email address. To allow the new user to
            * login to their new account, you need to create a new [account
            * session](https://appconda.io/docs/references/cloud/client-web/account#createEmailSession).
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} name
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        create<Preferences extends Models.Preferences>(userId: string, email: string, password: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Update email
            *
            * Update currently logged in user account email address. After changing user
            * address, the user confirmation status will get reset. A new confirmation
            * email is not sent automatically however you can use the send confirmation
            * email endpoint again to send the confirmation email. For security measures,
            * user password is required to complete this request.
            * This endpoint can also be used to convert an anonymous account to a normal
            * one, by passing an email address and a new password.
            *
            *
            * @param {string} email
            * @param {string} password
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateEmail<Preferences extends Models.Preferences>(email: string, password: string): Promise<Models.User<Preferences>>;
        /**
            * List Identities
            *
            * Get the list of identities for the currently logged in user.
            *
            * @param {string[]} queries
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listIdentities(queries?: string[]): Promise<Models.IdentityList>;
        /**
            * Delete identity
            *
            * Delete an identity by its unique ID.
            *
            * @param {string} identityId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteIdentity(identityId: string): Promise<{}>;
        /**
            * Create JWT
            *
            * Use this endpoint to create a JSON Web Token. You can use the resulting JWT
            * to authenticate on behalf of the current user when working with the
            * Appconda server-side API and SDKs. The JWT secret is valid for 15 minutes
            * from its creation and will be invalid if the user will logout in that time
            * frame.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createJWT(): Promise<Models.Jwt>;
        /**
            * List logs
            *
            * Get the list of latest security activity logs for the currently logged in
            * user. Each log returns user IP address, location and date and time of log.
            *
            * @param {string[]} queries
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listLogs(queries?: string[]): Promise<Models.LogList>;
        /**
            * Update MFA
            *
            * Enable or disable MFA on an account.
            *
            * @param {boolean} mfa
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMFA<Preferences extends Models.Preferences>(mfa: boolean): Promise<Models.User<Preferences>>;
        /**
            * Add Authenticator
            *
            * Add an authenticator app to be used as an MFA factor. Verify the
            * authenticator using the [verify
            * authenticator](/docs/references/cloud/client-web/account#updateMfaAuthenticator)
            * method.
            *
            * @param {AuthenticatorType} type
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createMfaAuthenticator(type: AuthenticatorType): Promise<Models.MfaType>;
        /**
            * Verify Authenticator
            *
            * Verify an authenticator app after adding it using the [add
            * authenticator](/docs/references/cloud/client-web/account#createMfaAuthenticator)
            * method. add
            *
            * @param {AuthenticatorType} type
            * @param {string} otp
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMfaAuthenticator<Preferences extends Models.Preferences>(type: AuthenticatorType, otp: string): Promise<Models.User<Preferences>>;
        /**
            * Delete Authenticator
            *
            * Delete an authenticator for a user by ID.
            *
            * @param {AuthenticatorType} type
            * @param {string} otp
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteMfaAuthenticator(type: AuthenticatorType, otp: string): Promise<{}>;
        /**
            * Create 2FA Challenge
            *
            * Begin the process of MFA verification after sign-in. Finish the flow with
            * [updateMfaChallenge](/docs/references/cloud/client-web/account#updateMfaChallenge)
            * method.
            *
            * @param {AuthenticationFactor} factor
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createMfaChallenge(factor: AuthenticationFactor): Promise<Models.MfaChallenge>;
        /**
            * Create MFA Challenge (confirmation)
            *
            * Complete the MFA challenge by providing the one-time password. Finish the
            * process of MFA verification by providing the one-time password. To begin
            * the flow, use
            * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)
            * method.
            *
            * @param {string} challengeId
            * @param {string} otp
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMfaChallenge(challengeId: string, otp: string): Promise<{}>;
        /**
            * List Factors
            *
            * List the factors available on the account to be used as a MFA challange.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listMfaFactors(): Promise<Models.MfaFactors>;
        /**
            * Get MFA Recovery Codes
            *
            * Get recovery codes that can be used as backup for MFA flow. Before getting
            * codes, they must be generated using
            * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)
            * method. An OTP challenge is required to read recovery codes.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getMfaRecoveryCodes(): Promise<Models.MfaRecoveryCodes>;
        /**
            * Create MFA Recovery Codes
            *
            * Generate recovery codes as backup for MFA flow. It's recommended to
            * generate and show then immediately after user successfully adds their
            * authehticator. Recovery codes can be used as a MFA verification type in
            * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)
            * method.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createMfaRecoveryCodes(): Promise<Models.MfaRecoveryCodes>;
        /**
            * Regenerate MFA Recovery Codes
            *
            * Regenerate recovery codes that can be used as backup for MFA flow. Before
            * regenerating codes, they must be first generated using
            * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)
            * method. An OTP challenge is required to regenreate recovery codes.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMfaRecoveryCodes(): Promise<Models.MfaRecoveryCodes>;
        /**
            * Update name
            *
            * Update currently logged in user account name.
            *
            * @param {string} name
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateName<Preferences extends Models.Preferences>(name: string): Promise<Models.User<Preferences>>;
        /**
            * Update password
            *
            * Update currently logged in user password. For validation, user is required
            * to pass in the new password, and the old password. For users created with
            * OAuth, Team Invites and Magic URL, oldPassword is optional.
            *
            * @param {string} password
            * @param {string} oldPassword
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePassword<Preferences extends Models.Preferences>(password: string, oldPassword?: string): Promise<Models.User<Preferences>>;
        /**
            * Update phone
            *
            * Update the currently logged in user's phone number. After updating the
            * phone number, the phone verification status will be reset. A confirmation
            * SMS is not sent automatically, however you can use the [POST
            * /account/verification/phone](https://appconda.io/docs/references/cloud/client-web/account#createPhoneVerification)
            * endpoint to send a confirmation SMS.
            *
            * @param {string} phone
            * @param {string} password
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePhone<Preferences extends Models.Preferences>(phone: string, password: string): Promise<Models.User<Preferences>>;
        /**
            * Get account preferences
            *
            * Get the preferences as a key-value object for the currently logged in user.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getPrefs<Preferences extends Models.Preferences>(): Promise<Preferences>;
        /**
            * Update preferences
            *
            * Update currently logged in user account preferences. The object you pass is
            * stored as is, and replaces any previous value. The maximum allowed prefs
            * size is 64kB and throws error if exceeded.
            *
            * @param {Partial<Preferences>} prefs
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePrefs<Preferences extends Models.Preferences>(prefs: Partial<Preferences>): Promise<Models.User<Preferences>>;
        /**
            * Create password recovery
            *
            * Sends the user an email with a temporary secret key for password reset.
            * When the user clicks the confirmation link he is redirected back to your
            * app password reset URL with the secret key and email address values
            * attached to the URL query string. Use the query string params to submit a
            * request to the [PUT
            * /account/recovery](https://appconda.io/docs/references/cloud/client-web/account#updateRecovery)
            * endpoint to complete the process. The verification link sent to the user's
            * email address is valid for 1 hour.
            *
            * @param {string} email
            * @param {string} url
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createRecovery(email: string, url: string): Promise<Models.Token>;
        /**
            * Create password recovery (confirmation)
            *
            * Use this endpoint to complete the user account password reset. Both the
            * **userId** and **secret** arguments will be passed as query parameters to
            * the redirect URL you have provided when sending your request to the [POST
            * /account/recovery](https://appconda.io/docs/references/cloud/client-web/account#createRecovery)
            * endpoint.
            *
            * Please note that in order to avoid a [Redirect
            * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)
            * the only valid redirect URLs are the ones from domains you have set when
            * adding your platforms in the console interface.
            *
            * @param {string} userId
            * @param {string} secret
            * @param {string} password
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateRecovery(userId: string, secret: string, password: string): Promise<Models.Token>;
        /**
            * List sessions
            *
            * Get the list of active sessions across different devices for the currently
            * logged in user.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listSessions(): Promise<Models.SessionList>;
        /**
            * Delete sessions
            *
            * Delete all sessions from the user account and remove any sessions cookies
            * from the end client.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteSessions(): Promise<{}>;
        /**
            * Create anonymous session
            *
            * Use this endpoint to allow a new user to register an anonymous account in
            * your project. This route will also create a new session for the user. To
            * allow the new user to convert an anonymous account to a normal account, you
            * need to update its [email and
            * password](https://appconda.io/docs/references/cloud/client-web/account#updateEmail)
            * or create an [OAuth2
            * session](https://appconda.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createAnonymousSession(): Promise<Models.Session>;
        /**
            * Create email password session
            *
            * Allow the user to login into their account by providing a valid email and
            * password combination. This route will create a new session for the user.
            *
            * A user is limited to 10 active sessions at a time by default. [Learn more
            * about session
            * limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {string} email
            * @param {string} password
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createEmailPasswordSession(email: string, password: string): Promise<Models.Session>;
        /**
            * Update magic URL session
            *
            * Use this endpoint to create a session from token. Provide the **userId**
            * and **secret** parameters from the successful response of authentication
            * flows initiated by token creation. For example, magic URL and phone login.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMagicURLSession(userId: string, secret: string): Promise<Models.Session>;
        /**
            * Create OAuth2 session
            *
            * Allow the user to login to their account using the OAuth2 provider of their
            * choice. Each OAuth2 provider should be enabled from the Appconda console
            * first. Use the success and failure arguments to provide a redirect URL's
            * back to your app when login is completed.
            *
            * If there is already an active session, the new session will be attached to
            * the logged-in account. If there are no active sessions, the server will
            * attempt to look for a user with the same email address as the email
            * received from the OAuth2 provider and attach the new session to the
            * existing user. If no matching user is found - the server will create a new
            * user.
            *
            * A user is limited to 10 active sessions at a time by default. [Learn more
            * about session
            * limits](https://appconda.io/docs/authentication-security#limits).
            *
            *
            * @param {OAuthProvider} provider
            * @param {string} success
            * @param {string} failure
            * @param {string[]} scopes
            * @throws {AppwriteException}
            * @returns {void|string}
         */
        createOAuth2Session(provider: OAuthProvider, success?: string, failure?: string, scopes?: string[]): void | URL;
        /**
            * Update phone session
            *
            * Use this endpoint to create a session from token. Provide the **userId**
            * and **secret** parameters from the successful response of authentication
            * flows initiated by token creation. For example, magic URL and phone login.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePhoneSession(userId: string, secret: string): Promise<Models.Session>;
        /**
            * Create session
            *
            * Use this endpoint to create a session from token. Provide the **userId**
            * and **secret** parameters from the successful response of authentication
            * flows initiated by token creation. For example, magic URL and phone login.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createSession(userId: string, secret: string): Promise<Models.Session>;
        /**
            * Get session
            *
            * Use this endpoint to get a logged in user's session using a Session ID.
            * Inputting 'current' will return the current session being used.
            *
            * @param {string} sessionId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getSession(sessionId: string): Promise<Models.Session>;
        /**
            * Update session
            *
            * Use this endpoint to extend a session's length. Extending a session is
            * useful when session expiry is short. If the session was created using an
            * OAuth provider, this endpoint refreshes the access token from the provider.
            *
            * @param {string} sessionId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateSession(sessionId: string): Promise<Models.Session>;
        /**
            * Delete session
            *
            * Logout the user. Use 'current' as the session ID to logout on this device,
            * use a session ID to logout on another device. If you're looking to logout
            * the user on all devices, use [Delete
            * Sessions](https://appconda.io/docs/references/cloud/client-web/account#deleteSessions)
            * instead.
            *
            * @param {string} sessionId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteSession(sessionId: string): Promise<{}>;
        /**
            * Update status
            *
            * Block the currently logged in user account. Behind the scene, the user
            * record is not deleted but permanently blocked from any access. To
            * completely delete a user, use the Users API instead.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateStatus<Preferences extends Models.Preferences>(): Promise<Models.User<Preferences>>;
        /**
            * Create push target
            *
            *
            * @param {string} targetId
            * @param {string} identifier
            * @param {string} providerId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createPushTarget(targetId: string, identifier: string, providerId?: string): Promise<Models.Target>;
        /**
            * Update push target
            *
            *
            * @param {string} targetId
            * @param {string} identifier
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePushTarget(targetId: string, identifier: string): Promise<Models.Target>;
        /**
            * Delete push target
            *
            *
            * @param {string} targetId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deletePushTarget(targetId: string): Promise<{}>;
        /**
            * Create email token (OTP)
            *
            * Sends the user an email with a secret key for creating a session. If the
            * provided user ID has not be registered, a new user will be created. Use the
            * returned user ID and secret and submit a request to the [POST
            * /v1/account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession)
            * endpoint to complete the login process. The secret sent to the user's email
            * is valid for 15 minutes.
            *
            * A user is limited to 10 active sessions at a time by default. [Learn more
            * about session
            * limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {string} userId
            * @param {string} email
            * @param {boolean} phrase
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createEmailToken(userId: string, email: string, phrase?: boolean): Promise<Models.Token>;
        /**
            * Create magic URL token
            *
            * Sends the user an email with a secret key for creating a session. If the
            * provided user ID has not been registered, a new user will be created. When
            * the user clicks the link in the email, the user is redirected back to the
            * URL you provided with the secret key and userId values attached to the URL
            * query string. Use the query string parameters to submit a request to the
            * [POST
            * /v1/account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession)
            * endpoint to complete the login process. The link sent to the user's email
            * address is valid for 1 hour. If you are on a mobile device you can leave
            * the URL parameter empty, so that the login completion will be handled by
            * your Appconda instance by default.
            *
            * A user is limited to 10 active sessions at a time by default. [Learn more
            * about session
            * limits](https://appconda.io/docs/authentication-security#limits).
            *
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} url
            * @param {boolean} phrase
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createMagicURLToken(userId: string, email: string, url?: string, phrase?: boolean): Promise<Models.Token>;
        /**
            * Create OAuth2 token
            *
            * Allow the user to login to their account using the OAuth2 provider of their
            * choice. Each OAuth2 provider should be enabled from the Appconda console
            * first. Use the success and failure arguments to provide a redirect URL's
            * back to your app when login is completed.
            *
            * If authentication succeeds, `userId` and `secret` of a token will be
            * appended to the success URL as query parameters. These can be used to
            * create a new session using the [Create
            * session](https://appconda.io/docs/references/cloud/client-web/account#createSession)
            * endpoint.
            *
            * A user is limited to 10 active sessions at a time by default. [Learn more
            * about session
            * limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {OAuthProvider} provider
            * @param {string} success
            * @param {string} failure
            * @param {string[]} scopes
            * @throws {AppwriteException}
            * @returns {void|string}
         */
        createOAuth2Token(provider: OAuthProvider, success?: string, failure?: string, scopes?: string[]): void | URL;
        /**
            * Create phone token
            *
            * Sends the user an SMS with a secret key for creating a session. If the
            * provided user ID has not be registered, a new user will be created. Use the
            * returned user ID and secret and submit a request to the [POST
            * /v1/account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession)
            * endpoint to complete the login process. The secret sent to the user's phone
            * is valid for 15 minutes.
            *
            * A user is limited to 10 active sessions at a time by default. [Learn more
            * about session
            * limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {string} userId
            * @param {string} phone
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createPhoneToken(userId: string, phone: string): Promise<Models.Token>;
        /**
            * Create email verification
            *
            * Use this endpoint to send a verification message to your user email address
            * to confirm they are the valid owners of that address. Both the **userId**
            * and **secret** arguments will be passed as query parameters to the URL you
            * have provided to be attached to the verification email. The provided URL
            * should redirect the user back to your app and allow you to complete the
            * verification process by verifying both the **userId** and **secret**
            * parameters. Learn more about how to [complete the verification
            * process](https://appconda.io/docs/references/cloud/client-web/account#updateVerification).
            * The verification link sent to the user's email address is valid for 7 days.
            *
            * Please note that in order to avoid a [Redirect
            * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),
            * the only valid redirect URLs are the ones from domains you have set when
            * adding your platforms in the console interface.
            *
            *
            * @param {string} url
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createVerification(url: string): Promise<Models.Token>;
        /**
            * Create email verification (confirmation)
            *
            * Use this endpoint to complete the user email verification process. Use both
            * the **userId** and **secret** parameters that were attached to your app URL
            * to verify the user email ownership. If confirmed this route will return a
            * 200 status code.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateVerification(userId: string, secret: string): Promise<Models.Token>;
        /**
            * Create phone verification
            *
            * Use this endpoint to send a verification SMS to the currently logged in
            * user. This endpoint is meant for use after updating a user's phone number
            * using the
            * [accountUpdatePhone](https://appconda.io/docs/references/cloud/client-web/account#updatePhone)
            * endpoint. Learn more about how to [complete the verification
            * process](https://appconda.io/docs/references/cloud/client-web/account#updatePhoneVerification).
            * The verification code sent to the user's phone number is valid for 15
            * minutes.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createPhoneVerification(): Promise<Models.Token>;
        /**
            * Create phone verification (confirmation)
            *
            * Use this endpoint to complete the user phone verification process. Use the
            * **userId** and **secret** that were sent to your user's phone number to
            * verify the user email ownership. If confirmed this route will return a 200
            * status code.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePhoneVerification(userId: string, secret: string): Promise<Models.Token>;
}

export class Avatars extends Service {
        constructor(client: Client);
        /**
            * Get browser icon
            *
            * You can use this endpoint to show different browser icons to your users.
            * The code argument receives the browser code as it appears in your user [GET
            * /account/sessions](https://appconda.io/docs/references/cloud/client-web/account#getSessions)
            * endpoint. Use width, height and quality arguments to change the output
            * settings.
            *
            * When one dimension is specified and the other is 0, the image is scaled
            * with preserved aspect ratio. If both dimensions are 0, the API provides an
            * image at source quality. If dimensions are not specified, the default size
            * of image returned is 100x100px.
            *
            * @param {Browser} code
            * @param {number} width
            * @param {number} height
            * @param {number} quality
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getBrowser(code: Browser, width?: number, height?: number, quality?: number): URL;
        /**
            * Get credit card icon
            *
            * The credit card endpoint will return you the icon of the credit card
            * provider you need. Use width, height and quality arguments to change the
            * output settings.
            *
            * When one dimension is specified and the other is 0, the image is scaled
            * with preserved aspect ratio. If both dimensions are 0, the API provides an
            * image at source quality. If dimensions are not specified, the default size
            * of image returned is 100x100px.
            *
            *
            * @param {CreditCard} code
            * @param {number} width
            * @param {number} height
            * @param {number} quality
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getCreditCard(code: CreditCard, width?: number, height?: number, quality?: number): URL;
        /**
            * Get favicon
            *
            * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote
            * website URL.
            *
            *
            * @param {string} url
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getFavicon(url: string): URL;
        /**
            * Get country flag
            *
            * You can use this endpoint to show different country flags icons to your
            * users. The code argument receives the 2 letter country code. Use width,
            * height and quality arguments to change the output settings. Country codes
            * follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.
            *
            * When one dimension is specified and the other is 0, the image is scaled
            * with preserved aspect ratio. If both dimensions are 0, the API provides an
            * image at source quality. If dimensions are not specified, the default size
            * of image returned is 100x100px.
            *
            *
            * @param {Flag} code
            * @param {number} width
            * @param {number} height
            * @param {number} quality
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getFlag(code: Flag, width?: number, height?: number, quality?: number): URL;
        /**
            * Get image from URL
            *
            * Use this endpoint to fetch a remote image URL and crop it to any image size
            * you want. This endpoint is very useful if you need to crop and display
            * remote images in your app or in case you want to make sure a 3rd party
            * image is properly served using a TLS protocol.
            *
            * When one dimension is specified and the other is 0, the image is scaled
            * with preserved aspect ratio. If both dimensions are 0, the API provides an
            * image at source quality. If dimensions are not specified, the default size
            * of image returned is 400x400px.
            *
            *
            * @param {string} url
            * @param {number} width
            * @param {number} height
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getImage(url: string, width?: number, height?: number): URL;
        /**
            * Get user initials
            *
            * Use this endpoint to show your user initials avatar icon on your website or
            * app. By default, this route will try to print your logged-in user name or
            * email initials. You can also overwrite the user name if you pass the 'name'
            * parameter. If no name is given and no user is logged, an empty avatar will
            * be returned.
            *
            * You can use the color and background params to change the avatar colors. By
            * default, a random theme will be selected. The random theme will persist for
            * the user's initials when reloading the same theme will always return for
            * the same initials.
            *
            * When one dimension is specified and the other is 0, the image is scaled
            * with preserved aspect ratio. If both dimensions are 0, the API provides an
            * image at source quality. If dimensions are not specified, the default size
            * of image returned is 100x100px.
            *
            *
            * @param {string} name
            * @param {number} width
            * @param {number} height
            * @param {string} background
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getInitials(name?: string, width?: number, height?: number, background?: string): URL;
        /**
            * Get QR code
            *
            * Converts a given plain text to a QR code image. You can use the query
            * parameters to change the size and style of the resulting image.
            *
            *
            * @param {string} text
            * @param {number} size
            * @param {number} margin
            * @param {boolean} download
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getQR(text: string, size?: number, margin?: number, download?: boolean): URL;
}

export class Databases extends Service {
        constructor(client: Client);
        /**
            * List documents
            *
            * Get a list of all the user's documents in a given collection. You can use
            * the query params to filter your results.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string[]} queries
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listDocuments<Document extends Models.Document>(databaseId: string, collectionId: string, queries?: string[]): Promise<Models.DocumentList<Document>>;
        /**
            * Create document
            *
            * Create a new Document. Before using this route, you should create a new
            * collection resource using either a [server
            * integration](https://appconda.io/docs/server/databases#databasesCreateCollection)
            * API or directly from your database console.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {Omit<Document, keyof Models.Document>} data
            * @param {string[]} permissions
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createDocument<Document extends Models.Document>(databaseId: string, collectionId: string, documentId: string, data: Omit<Document, keyof Models.Document>, permissions?: string[]): Promise<Document>;
        /**
            * Get document
            *
            * Get a document by its unique ID. This endpoint response returns a JSON
            * object with the document data.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {string[]} queries
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getDocument<Document extends Models.Document>(databaseId: string, collectionId: string, documentId: string, queries?: string[]): Promise<Document>;
        /**
            * Update document
            *
            * Update a document by its unique ID. Using the patch method you can pass
            * only specific fields that will get updated.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {Partial<Omit<Document, keyof Models.Document>>} data
            * @param {string[]} permissions
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateDocument<Document extends Models.Document>(databaseId: string, collectionId: string, documentId: string, data?: Partial<Omit<Document, keyof Models.Document>>, permissions?: string[]): Promise<Document>;
        /**
            * Delete document
            *
            * Delete a document by its unique ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteDocument(databaseId: string, collectionId: string, documentId: string): Promise<{}>;
}

export class Functions extends Service {
        constructor(client: Client);
        /**
            * List executions
            *
            * Get a list of all the current user function execution logs. You can use the
            * query params to filter your results.
            *
            * @param {string} functionId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listExecutions(functionId: string, queries?: string[], search?: string): Promise<Models.ExecutionList>;
        /**
            * Create execution
            *
            * Trigger a function execution. The returned object will return you the
            * current execution status. You can ping the `Get Execution` endpoint to get
            * updates on the current execution status. Once this endpoint is called, your
            * function execution process will start asynchronously.
            *
            * @param {string} functionId
            * @param {string} body
            * @param {boolean} async
            * @param {string} xpath
            * @param {ExecutionMethod} method
            * @param {object} headers
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createExecution(functionId: string, body?: string, async?: boolean, xpath?: string, method?: ExecutionMethod, headers?: object): Promise<Models.Execution>;
        /**
            * Get execution
            *
            * Get a function execution log by its unique ID.
            *
            * @param {string} functionId
            * @param {string} executionId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getExecution(functionId: string, executionId: string): Promise<Models.Execution>;
}

export class Graphql extends Service {
        constructor(client: Client);
        /**
            * GraphQL endpoint
            *
            * Execute a GraphQL mutation.
            *
            * @param {object} query
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        query(query: object): Promise<{}>;
        /**
            * GraphQL endpoint
            *
            * Execute a GraphQL mutation.
            *
            * @param {object} query
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        mutation(query: object): Promise<{}>;
}

export class Locale extends Service {
        constructor(client: Client);
        /**
            * Get user locale
            *
            * Get the current user location based on IP. Returns an object with user
            * country code, country name, continent name, continent code, ip address and
            * suggested currency. You can use the locale header to get the data in a
            * supported language.
            *
            * ([IP Geolocation by DB-IP](https://db-ip.com))
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        get(): Promise<Models.Locale>;
        /**
            * List Locale Codes
            *
            * List of all locale codes in [ISO
            * 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listCodes(): Promise<Models.LocaleCodeList>;
        /**
            * List continents
            *
            * List of all continents. You can use the locale header to get the data in a
            * supported language.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listContinents(): Promise<Models.ContinentList>;
        /**
            * List countries
            *
            * List of all countries. You can use the locale header to get the data in a
            * supported language.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listCountries(): Promise<Models.CountryList>;
        /**
            * List EU countries
            *
            * List of all countries that are currently members of the EU. You can use the
            * locale header to get the data in a supported language.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listCountriesEU(): Promise<Models.CountryList>;
        /**
            * List countries phone codes
            *
            * List of all countries phone codes. You can use the locale header to get the
            * data in a supported language.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listCountriesPhones(): Promise<Models.PhoneList>;
        /**
            * List currencies
            *
            * List of all currencies, including currency symbol, name, plural, and
            * decimal digits for all major and minor currencies. You can use the locale
            * header to get the data in a supported language.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listCurrencies(): Promise<Models.CurrencyList>;
        /**
            * List languages
            *
            * List of all languages classified by ISO 639-1 including 2-letter code, name
            * in English, and name in the respective language.
            *
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listLanguages(): Promise<Models.LanguageList>;
}

export class Messaging extends Service {
        constructor(client: Client);
        /**
            * Create subscriber
            *
            * Create a new subscriber.
            *
            * @param {string} topicId
            * @param {string} subscriberId
            * @param {string} targetId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createSubscriber(topicId: string, subscriberId: string, targetId: string): Promise<Models.Subscriber>;
        /**
            * Delete subscriber
            *
            * Delete a subscriber by its unique ID.
            *
            * @param {string} topicId
            * @param {string} subscriberId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteSubscriber(topicId: string, subscriberId: string): Promise<{}>;
}

export class Storage extends Service {
        constructor(client: Client);
        /**
            * List files
            *
            * Get a list of all the user files. You can use the query params to filter
            * your results.
            *
            * @param {string} bucketId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listFiles(bucketId: string, queries?: string[], search?: string): Promise<Models.FileList>;
        /**
            * Create file
            *
            * Create a new file. Before using this route, you should create a new bucket
            * resource using either a [server
            * integration](https://appconda.io/docs/server/storage#storageCreateBucket)
            * API or directly from your Appconda console.
            *
            * Larger files should be uploaded using multiple requests with the
            * [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range)
            * header to send a partial request with a maximum supported chunk of `5MB`.
            * The `content-range` header values should always be in bytes.
            *
            * When the first request is sent, the server will return the **File** object,
            * and the subsequent part request must include the file's **id** in
            * `x-appconda-id` header to allow the server to know that the partial upload
            * is for the existing file and not for a new one.
            *
            * If you're creating a new file using one of the Appconda SDKs, all the
            * chunking logic will be managed by the SDK internally.
            *
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @param {File} file
            * @param {string[]} permissions
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createFile(bucketId: string, fileId: string, file: File, permissions?: string[], onProgress?: (progress: UploadProgress) => void): Promise<Models.File>;
        /**
            * Get file
            *
            * Get a file by its unique ID. This endpoint response returns a JSON object
            * with the file metadata.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getFile(bucketId: string, fileId: string): Promise<Models.File>;
        /**
            * Update file
            *
            * Update a file by its unique ID. Only users with write permissions have
            * access to update this resource.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @param {string} name
            * @param {string[]} permissions
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateFile(bucketId: string, fileId: string, name?: string, permissions?: string[]): Promise<Models.File>;
        /**
            * Delete File
            *
            * Delete a file by its unique ID. Only users with write permissions have
            * access to delete this resource.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteFile(bucketId: string, fileId: string): Promise<{}>;
        /**
            * Get file for download
            *
            * Get a file content by its unique ID. The endpoint response return with a
            * 'Content-Disposition: attachment' header that tells the browser to start
            * downloading the file to user downloads directory.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getFileDownload(bucketId: string, fileId: string): URL;
        /**
            * Get file preview
            *
            * Get a file preview image. Currently, this method supports preview for image
            * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,
            * and spreadsheets, will return the file icon image. You can also pass query
            * string arguments for cutting and resizing your preview image. Preview is
            * supported only for image files smaller than 10MB.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @param {number} width
            * @param {number} height
            * @param {ImageGravity} gravity
            * @param {number} quality
            * @param {number} borderWidth
            * @param {string} borderColor
            * @param {number} borderRadius
            * @param {number} opacity
            * @param {number} rotation
            * @param {string} background
            * @param {ImageFormat} output
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getFilePreview(bucketId: string, fileId: string, width?: number, height?: number, gravity?: ImageGravity, quality?: number, borderWidth?: number, borderColor?: string, borderRadius?: number, opacity?: number, rotation?: number, background?: string, output?: ImageFormat): URL;
        /**
            * Get file for view
            *
            * Get a file content by its unique ID. This endpoint is similar to the
            * download method but returns with no  'Content-Disposition: attachment'
            * header.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppwriteException}
            * @returns {URL}
         */
        getFileView(bucketId: string, fileId: string): URL;
}

export class Teams extends Service {
        constructor(client: Client);
        /**
            * List teams
            *
            * Get a list of all the teams in which the current user is a member. You can
            * use the parameters to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        list<Preferences extends Models.Preferences>(queries?: string[], search?: string): Promise<Models.TeamList<Preferences>>;
        /**
            * Create team
            *
            * Create a new team. The user who creates the team will automatically be
            * assigned as the owner of the team. Only the users with the owner role can
            * invite new members, add new owners and delete or update the team.
            *
            * @param {string} teamId
            * @param {string} name
            * @param {string[]} roles
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        create<Preferences extends Models.Preferences>(teamId: string, name: string, roles?: string[]): Promise<Models.Team<Preferences>>;
        /**
            * Get team
            *
            * Get a team by its ID. All team members have read access for this resource.
            *
            * @param {string} teamId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        get<Preferences extends Models.Preferences>(teamId: string): Promise<Models.Team<Preferences>>;
        /**
            * Update name
            *
            * Update the team's name by its unique ID.
            *
            * @param {string} teamId
            * @param {string} name
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateName<Preferences extends Models.Preferences>(teamId: string, name: string): Promise<Models.Team<Preferences>>;
        /**
            * Delete team
            *
            * Delete a team using its ID. Only team members with the owner role can
            * delete the team.
            *
            * @param {string} teamId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        delete(teamId: string): Promise<{}>;
        /**
            * List team memberships
            *
            * Use this endpoint to list a team's members using the team's ID. All team
            * members have read access to this endpoint.
            *
            * @param {string} teamId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        listMemberships(teamId: string, queries?: string[], search?: string): Promise<Models.MembershipList>;
        /**
            * Create team membership
            *
            * Invite a new member to join your team. Provide an ID for existing users, or
            * invite unregistered users using an email or phone number. If initiated from
            * a Client SDK, Appconda will send an email or sms with a link to join the
            * team to the invited user, and an account will be created for them if one
            * doesn't exist. If initiated from a Server SDK, the new member will be added
            * automatically to the team.
            *
            * You only need to provide one of a user ID, email, or phone number. Appconda
            * will prioritize accepting the user ID > email > phone number if you provide
            * more than one of these parameters.
            *
            * Use the `url` parameter to redirect the user from the invitation email to
            * your app. After the user is redirected, use the [Update Team Membership
            * Status](https://appconda.io/docs/references/cloud/client-web/teams#updateMembershipStatus)
            * endpoint to allow the user to accept the invitation to the team.
            *
            * Please note that to avoid a [Redirect
            * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)
            * Appconda will accept the only redirect URLs under the domains you have
            * added as a platform on the Appconda Console.
            *
            *
            * @param {string} teamId
            * @param {string[]} roles
            * @param {string} email
            * @param {string} userId
            * @param {string} phone
            * @param {string} url
            * @param {string} name
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        createMembership(teamId: string, roles: string[], email?: string, userId?: string, phone?: string, url?: string, name?: string): Promise<Models.Membership>;
        /**
            * Get team membership
            *
            * Get a team member by the membership unique id. All team members have read
            * access for this resource.
            *
            * @param {string} teamId
            * @param {string} membershipId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getMembership(teamId: string, membershipId: string): Promise<Models.Membership>;
        /**
            * Update membership
            *
            * Modify the roles of a team member. Only team members with the owner role
            * have access to this endpoint. Learn more about [roles and
            * permissions](https://appconda.io/docs/permissions).
            *
            *
            * @param {string} teamId
            * @param {string} membershipId
            * @param {string[]} roles
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMembership(teamId: string, membershipId: string, roles: string[]): Promise<Models.Membership>;
        /**
            * Delete team membership
            *
            * This endpoint allows a user to leave a team or for a team owner to delete
            * the membership of any other team member. You can also use this endpoint to
            * delete a user membership even if it is not accepted.
            *
            * @param {string} teamId
            * @param {string} membershipId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        deleteMembership(teamId: string, membershipId: string): Promise<{}>;
        /**
            * Update team membership status
            *
            * Use this endpoint to allow a user to accept an invitation to join a team
            * after being redirected back to your app from the invitation email received
            * by the user.
            *
            * If the request is successful, a session for the user is automatically
            * created.
            *
            *
            * @param {string} teamId
            * @param {string} membershipId
            * @param {string} userId
            * @param {string} secret
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updateMembershipStatus(teamId: string, membershipId: string, userId: string, secret: string): Promise<Models.Membership>;
        /**
            * Get team preferences
            *
            * Get the team's shared preferences by its unique ID. If a preference doesn't
            * need to be shared by all team members, prefer storing them in [user
            * preferences](https://appconda.io/docs/references/cloud/client-web/account#getPrefs).
            *
            * @param {string} teamId
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        getPrefs<Preferences extends Models.Preferences>(teamId: string): Promise<Preferences>;
        /**
            * Update preferences
            *
            * Update the team's preferences by its unique ID. The object you pass is
            * stored as is and replaces any previous value. The maximum allowed prefs
            * size is 64kB and throws an error if exceeded.
            *
            * @param {string} teamId
            * @param {object} prefs
            * @throws {AppwriteException}
            * @returns {Promise}
         */
        updatePrefs<Preferences extends Models.Preferences>(teamId: string, prefs: object): Promise<Preferences>;
}

type QueryTypesSingle = string | number | boolean;
export type QueryTypesList = string[] | number[] | boolean[] | Query[];
export type QueryTypes = QueryTypesSingle | QueryTypesList;
type AttributesTypes = string | string[];
export class Query {
    method: string;
    attribute: AttributesTypes | undefined;
    values: QueryTypesList | undefined;
    constructor(method: string, attribute?: AttributesTypes, values?: QueryTypes);
    toString(): string;
    static equal: (attribute: string, value: QueryTypes) => string;
    static notEqual: (attribute: string, value: QueryTypes) => string;
    static lessThan: (attribute: string, value: QueryTypes) => string;
    static lessThanEqual: (attribute: string, value: QueryTypes) => string;
    static greaterThan: (attribute: string, value: QueryTypes) => string;
    static greaterThanEqual: (attribute: string, value: QueryTypes) => string;
    static isNull: (attribute: string) => string;
    static isNotNull: (attribute: string) => string;
    static between: (attribute: string, start: string | number, end: string | number) => string;
    static startsWith: (attribute: string, value: string) => string;
    static endsWith: (attribute: string, value: string) => string;
    static select: (attributes: string[]) => string;
    static search: (attribute: string, value: string) => string;
    static orderDesc: (attribute: string) => string;
    static orderAsc: (attribute: string) => string;
    static cursorAfter: (documentId: string) => string;
    static cursorBefore: (documentId: string) => string;
    static limit: (limit: number) => string;
    static offset: (offset: number) => string;
    static contains: (attribute: string, value: string | string[]) => string;
    static or: (queries: string[]) => string;
    static and: (queries: string[]) => string;
}
export {};

export class Permission {
    static read: (role: string) => string;
    static write: (role: string) => string;
    static create: (role: string) => string;
    static update: (role: string) => string;
    static delete: (role: string) => string;
}

/**
    * Helper class to generate role strings for `Permission`.
    */
export class Role {
        /**
            * Grants access to anyone.
            *
            * This includes authenticated and unauthenticated users.
            *
            * @returns {string}
            */
        static any(): string;
        /**
            * Grants access to a specific user by user ID.
            *
            * You can optionally pass verified or unverified for
            * `status` to target specific types of users.
            *
            * @param {string} id
            * @param {string} status
            * @returns {string}
            */
        static user(id: string, status?: string): string;
        /**
            * Grants access to any authenticated or anonymous user.
            *
            * You can optionally pass verified or unverified for
            * `status` to target specific types of users.
            *
            * @param {string} status
            * @returns {string}
            */
        static users(status?: string): string;
        /**
            * Grants access to any guest user without a session.
            *
            * Authenticated users don't have access to this role.
            *
            * @returns {string}
            */
        static guests(): string;
        /**
            * Grants access to a team by team ID.
            *
            * You can optionally pass a role for `role` to target
            * team members with the specified role.
            *
            * @param {string} id
            * @param {string} role
            * @returns {string}
            */
        static team(id: string, role?: string): string;
        /**
            * Grants access to a specific member of a team.
            *
            * When the member is removed from the team, they will
            * no longer have access.
            *
            * @param {string} id
            * @returns {string}
            */
        static member(id: string): string;
        /**
            * Grants access to a user with the specified label.
            *
            * @param {string} name
            * @returns  {string}
            */
        static label(name: string): string;
}

export class ID {
    #private;
    static custom(id: string): string;
    static unique(padding?: number): string;
}

export enum AuthenticatorType {
    Totp = "totp"
}

export enum AuthenticationFactor {
    Email = "email",
    Phone = "phone",
    Totp = "totp",
    Recoverycode = "recoverycode"
}

export enum OAuthProvider {
    Amazon = "amazon",
    Apple = "apple",
    Auth0 = "auth0",
    Authentik = "authentik",
    Autodesk = "autodesk",
    Bitbucket = "bitbucket",
    Bitly = "bitly",
    Box = "box",
    Dailymotion = "dailymotion",
    Discord = "discord",
    Disqus = "disqus",
    Dropbox = "dropbox",
    Etsy = "etsy",
    Facebook = "facebook",
    Github = "github",
    Gitlab = "gitlab",
    Google = "google",
    Linkedin = "linkedin",
    Microsoft = "microsoft",
    Notion = "notion",
    Oidc = "oidc",
    Okta = "okta",
    Paypal = "paypal",
    PaypalSandbox = "paypalSandbox",
    Podio = "podio",
    Salesforce = "salesforce",
    Slack = "slack",
    Spotify = "spotify",
    Stripe = "stripe",
    Tradeshift = "tradeshift",
    TradeshiftBox = "tradeshiftBox",
    Twitch = "twitch",
    Wordpress = "wordpress",
    Yahoo = "yahoo",
    Yammer = "yammer",
    Yandex = "yandex",
    Zoho = "zoho",
    Zoom = "zoom",
    Mock = "mock"
}

export enum Browser {
    AvantBrowser = "aa",
    AndroidWebViewBeta = "an",
    GoogleChrome = "ch",
    GoogleChromeIOS = "ci",
    GoogleChromeMobile = "cm",
    Chromium = "cr",
    MozillaFirefox = "ff",
    Safari = "sf",
    MobileSafari = "mf",
    MicrosoftEdge = "ps",
    MicrosoftEdgeIOS = "oi",
    OperaMini = "om",
    Opera = "op",
    OperaNext = "on"
}

export enum CreditCard {
    AmericanExpress = "amex",
    Argencard = "argencard",
    Cabal = "cabal",
    Cencosud = "cencosud",
    DinersClub = "diners",
    Discover = "discover",
    Elo = "elo",
    Hipercard = "hipercard",
    JCB = "jcb",
    Mastercard = "mastercard",
    Naranja = "naranja",
    TarjetaShopping = "targeta-shopping",
    UnionChinaPay = "union-china-pay",
    Visa = "visa",
    MIR = "mir",
    Maestro = "maestro"
}

export enum Flag {
    Afghanistan = "af",
    Angola = "ao",
    Albania = "al",
    Andorra = "ad",
    UnitedArabEmirates = "ae",
    Argentina = "ar",
    Armenia = "am",
    AntiguaAndBarbuda = "ag",
    Australia = "au",
    Austria = "at",
    Azerbaijan = "az",
    Burundi = "bi",
    Belgium = "be",
    Benin = "bj",
    BurkinaFaso = "bf",
    Bangladesh = "bd",
    Bulgaria = "bg",
    Bahrain = "bh",
    Bahamas = "bs",
    BosniaAndHerzegovina = "ba",
    Belarus = "by",
    Belize = "bz",
    Bolivia = "bo",
    Brazil = "br",
    Barbados = "bb",
    BruneiDarussalam = "bn",
    Bhutan = "bt",
    Botswana = "bw",
    CentralAfricanRepublic = "cf",
    Canada = "ca",
    Switzerland = "ch",
    Chile = "cl",
    China = "cn",
    CoteDIvoire = "ci",
    Cameroon = "cm",
    DemocraticRepublicOfTheCongo = "cd",
    RepublicOfTheCongo = "cg",
    Colombia = "co",
    Comoros = "km",
    CapeVerde = "cv",
    CostaRica = "cr",
    Cuba = "cu",
    Cyprus = "cy",
    CzechRepublic = "cz",
    Germany = "de",
    Djibouti = "dj",
    Dominica = "dm",
    Denmark = "dk",
    DominicanRepublic = "do",
    Algeria = "dz",
    Ecuador = "ec",
    Egypt = "eg",
    Eritrea = "er",
    Spain = "es",
    Estonia = "ee",
    Ethiopia = "et",
    Finland = "fi",
    Fiji = "fj",
    France = "fr",
    MicronesiaFederatedStatesOf = "fm",
    Gabon = "ga",
    UnitedKingdom = "gb",
    Georgia = "ge",
    Ghana = "gh",
    Guinea = "gn",
    Gambia = "gm",
    GuineaBissau = "gw",
    EquatorialGuinea = "gq",
    Greece = "gr",
    Grenada = "gd",
    Guatemala = "gt",
    Guyana = "gy",
    Honduras = "hn",
    Croatia = "hr",
    Haiti = "ht",
    Hungary = "hu",
    Indonesia = "id",
    India = "in",
    Ireland = "ie",
    IranIslamicRepublicOf = "ir",
    Iraq = "iq",
    Iceland = "is",
    Israel = "il",
    Italy = "it",
    Jamaica = "jm",
    Jordan = "jo",
    Japan = "jp",
    Kazakhstan = "kz",
    Kenya = "ke",
    Kyrgyzstan = "kg",
    Cambodia = "kh",
    Kiribati = "ki",
    SaintKittsAndNevis = "kn",
    SouthKorea = "kr",
    Kuwait = "kw",
    LaoPeopleSDemocraticRepublic = "la",
    Lebanon = "lb",
    Liberia = "lr",
    Libya = "ly",
    SaintLucia = "lc",
    Liechtenstein = "li",
    SriLanka = "lk",
    Lesotho = "ls",
    Lithuania = "lt",
    Luxembourg = "lu",
    Latvia = "lv",
    Morocco = "ma",
    Monaco = "mc",
    Moldova = "md",
    Madagascar = "mg",
    Maldives = "mv",
    Mexico = "mx",
    MarshallIslands = "mh",
    NorthMacedonia = "mk",
    Mali = "ml",
    Malta = "mt",
    Myanmar = "mm",
    Montenegro = "me",
    Mongolia = "mn",
    Mozambique = "mz",
    Mauritania = "mr",
    Mauritius = "mu",
    Malawi = "mw",
    Malaysia = "my",
    Namibia = "na",
    Niger = "ne",
    Nigeria = "ng",
    Nicaragua = "ni",
    Netherlands = "nl",
    Norway = "no",
    Nepal = "np",
    Nauru = "nr",
    NewZealand = "nz",
    Oman = "om",
    Pakistan = "pk",
    Panama = "pa",
    Peru = "pe",
    Philippines = "ph",
    Palau = "pw",
    PapuaNewGuinea = "pg",
    Poland = "pl",
    FrenchPolynesia = "pf",
    NorthKorea = "kp",
    Portugal = "pt",
    Paraguay = "py",
    Qatar = "qa",
    Romania = "ro",
    Russia = "ru",
    Rwanda = "rw",
    SaudiArabia = "sa",
    Sudan = "sd",
    Senegal = "sn",
    Singapore = "sg",
    SolomonIslands = "sb",
    SierraLeone = "sl",
    ElSalvador = "sv",
    SanMarino = "sm",
    Somalia = "so",
    Serbia = "rs",
    SouthSudan = "ss",
    SaoTomeAndPrincipe = "st",
    Suriname = "sr",
    Slovakia = "sk",
    Slovenia = "si",
    Sweden = "se",
    Eswatini = "sz",
    Seychelles = "sc",
    Syria = "sy",
    Chad = "td",
    Togo = "tg",
    Thailand = "th",
    Tajikistan = "tj",
    Turkmenistan = "tm",
    TimorLeste = "tl",
    Tonga = "to",
    TrinidadAndTobago = "tt",
    Tunisia = "tn",
    Turkey = "tr",
    Tuvalu = "tv",
    Tanzania = "tz",
    Uganda = "ug",
    Ukraine = "ua",
    Uruguay = "uy",
    UnitedStates = "us",
    Uzbekistan = "uz",
    VaticanCity = "va",
    SaintVincentAndTheGrenadines = "vc",
    Venezuela = "ve",
    Vietnam = "vn",
    Vanuatu = "vu",
    Samoa = "ws",
    Yemen = "ye",
    SouthAfrica = "za",
    Zambia = "zm",
    Zimbabwe = "zw"
}

export enum ExecutionMethod {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    PATCH = "PATCH",
    DELETE = "DELETE",
    OPTIONS = "OPTIONS"
}

export enum ImageGravity {
    Center = "center",
    Topleft = "top-left",
    Top = "top",
    Topright = "top-right",
    Left = "left",
    Right = "right",
    Bottomleft = "bottom-left",
    Bottom = "bottom",
    Bottomright = "bottom-right"
}

export enum ImageFormat {
    Jpg = "jpg",
    Jpeg = "jpeg",
    Gif = "gif",
    Png = "png",
    Webp = "webp"
}

export namespace Models {
        /**
            * Documents List
            */
        type DocumentList<Document extends Models.Document> = {
                /**
                    * Total number of documents documents that matched your query.
                    */
                total: number;
                /**
                    * List of documents.
                    */
                documents: Document[];
        };
        /**
            * Sessions List
            */
        type SessionList = {
                /**
                    * Total number of sessions documents that matched your query.
                    */
                total: number;
                /**
                    * List of sessions.
                    */
                sessions: Session[];
        };
        /**
            * Identities List
            */
        type IdentityList = {
                /**
                    * Total number of identities documents that matched your query.
                    */
                total: number;
                /**
                    * List of identities.
                    */
                identities: Identity[];
        };
        /**
            * Logs List
            */
        type LogList = {
                /**
                    * Total number of logs documents that matched your query.
                    */
                total: number;
                /**
                    * List of logs.
                    */
                logs: Log[];
        };
        /**
            * Files List
            */
        type FileList = {
                /**
                    * Total number of files documents that matched your query.
                    */
                total: number;
                /**
                    * List of files.
                    */
                files: File[];
        };
        /**
            * Teams List
            */
        type TeamList<Preferences extends Models.Preferences> = {
                /**
                    * Total number of teams documents that matched your query.
                    */
                total: number;
                /**
                    * List of teams.
                    */
                teams: Team<Preferences>[];
        };
        /**
            * Memberships List
            */
        type MembershipList = {
                /**
                    * Total number of memberships documents that matched your query.
                    */
                total: number;
                /**
                    * List of memberships.
                    */
                memberships: Membership[];
        };
        /**
            * Executions List
            */
        type ExecutionList = {
                /**
                    * Total number of executions documents that matched your query.
                    */
                total: number;
                /**
                    * List of executions.
                    */
                executions: Execution[];
        };
        /**
            * Countries List
            */
        type CountryList = {
                /**
                    * Total number of countries documents that matched your query.
                    */
                total: number;
                /**
                    * List of countries.
                    */
                countries: Country[];
        };
        /**
            * Continents List
            */
        type ContinentList = {
                /**
                    * Total number of continents documents that matched your query.
                    */
                total: number;
                /**
                    * List of continents.
                    */
                continents: Continent[];
        };
        /**
            * Languages List
            */
        type LanguageList = {
                /**
                    * Total number of languages documents that matched your query.
                    */
                total: number;
                /**
                    * List of languages.
                    */
                languages: Language[];
        };
        /**
            * Currencies List
            */
        type CurrencyList = {
                /**
                    * Total number of currencies documents that matched your query.
                    */
                total: number;
                /**
                    * List of currencies.
                    */
                currencies: Currency[];
        };
        /**
            * Phones List
            */
        type PhoneList = {
                /**
                    * Total number of phones documents that matched your query.
                    */
                total: number;
                /**
                    * List of phones.
                    */
                phones: Phone[];
        };
        /**
            * Locale codes list
            */
        type LocaleCodeList = {
                /**
                    * Total number of localeCodes documents that matched your query.
                    */
                total: number;
                /**
                    * List of localeCodes.
                    */
                localeCodes: LocaleCode[];
        };
        /**
            * Document
            */
        type Document = {
                /**
                    * Document ID.
                    */
                $id: string;
                /**
                    * Collection ID.
                    */
                $collectionId: string;
                /**
                    * Database ID.
                    */
                $databaseId: string;
                /**
                    * Document creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Document update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Document permissions. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                $permissions: string[];
                [key: string]: any;
        };
        /**
            * Log
            */
        type Log = {
                /**
                    * Event name.
                    */
                event: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * User Email.
                    */
                userEmail: string;
                /**
                    * User Name.
                    */
                userName: string;
                /**
                    * API mode when event triggered.
                    */
                mode: string;
                /**
                    * IP session in use when the session was created.
                    */
                ip: string;
                /**
                    * Log creation date in ISO 8601 format.
                    */
                time: string;
                /**
                    * Operating system code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/os.json).
                    */
                osCode: string;
                /**
                    * Operating system name.
                    */
                osName: string;
                /**
                    * Operating system version.
                    */
                osVersion: string;
                /**
                    * Client type.
                    */
                clientType: string;
                /**
                    * Client code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/clients.json).
                    */
                clientCode: string;
                /**
                    * Client name.
                    */
                clientName: string;
                /**
                    * Client version.
                    */
                clientVersion: string;
                /**
                    * Client engine name.
                    */
                clientEngine: string;
                /**
                    * Client engine name.
                    */
                clientEngineVersion: string;
                /**
                    * Device name.
                    */
                deviceName: string;
                /**
                    * Device brand name.
                    */
                deviceBrand: string;
                /**
                    * Device model name.
                    */
                deviceModel: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                countryCode: string;
                /**
                    * Country name.
                    */
                countryName: string;
        };
        /**
            * User
            */
        type User<Preferences extends Models.Preferences> = {
                /**
                    * User ID.
                    */
                $id: string;
                /**
                    * User creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * User update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User name.
                    */
                name: string;
                /**
                    * Hashed user password.
                    */
                password?: string;
                /**
                    * Password hashing algorithm.
                    */
                hash?: string;
                /**
                    * Password hashing algorithm configuration.
                    */
                hashOptions?: object;
                /**
                    * User registration date in ISO 8601 format.
                    */
                registration: string;
                /**
                    * User status. Pass `true` for enabled and `false` for disabled.
                    */
                status: boolean;
                /**
                    * Labels for the user.
                    */
                labels: string[];
                /**
                    * Password update time in ISO 8601 format.
                    */
                passwordUpdate: string;
                /**
                    * User email address.
                    */
                email: string;
                /**
                    * User phone number in E.164 format.
                    */
                phone: string;
                /**
                    * Email verification status.
                    */
                emailVerification: boolean;
                /**
                    * Phone verification status.
                    */
                phoneVerification: boolean;
                /**
                    * Multi factor authentication status.
                    */
                mfa: boolean;
                /**
                    * User preferences as a key-value object
                    */
                prefs: Preferences;
                /**
                    * A user-owned message receiver. A single user may have multiple e.g. emails, phones, and a browser. Each target is registered with a single provider.
                    */
                targets: Target[];
                /**
                    * Most recent access date in ISO 8601 format. This attribute is only updated again after 24 hours.
                    */
                accessedAt: string;
        };
        /**
            * AlgoMD5
            */
        type AlgoMd5 = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoSHA
            */
        type AlgoSha = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoPHPass
            */
        type AlgoPhpass = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoBcrypt
            */
        type AlgoBcrypt = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoScrypt
            */
        type AlgoScrypt = {
                /**
                    * Algo type.
                    */
                type: string;
                /**
                    * CPU complexity of computed hash.
                    */
                costCpu: number;
                /**
                    * Memory complexity of computed hash.
                    */
                costMemory: number;
                /**
                    * Parallelization of computed hash.
                    */
                costParallel: number;
                /**
                    * Length used to compute hash.
                    */
                length: number;
        };
        /**
            * AlgoScryptModified
            */
        type AlgoScryptModified = {
                /**
                    * Algo type.
                    */
                type: string;
                /**
                    * Salt used to compute hash.
                    */
                salt: string;
                /**
                    * Separator used to compute hash.
                    */
                saltSeparator: string;
                /**
                    * Key used to compute hash.
                    */
                signerKey: string;
        };
        /**
            * AlgoArgon2
            */
        type AlgoArgon2 = {
                /**
                    * Algo type.
                    */
                type: string;
                /**
                    * Memory used to compute hash.
                    */
                memoryCost: number;
                /**
                    * Amount of time consumed to compute hash
                    */
                timeCost: number;
                /**
                    * Number of threads used to compute hash.
                    */
                threads: number;
        };
        /**
            * Preferences
            */
        type Preferences = {
                [key: string]: any;
        };
        /**
            * Session
            */
        type Session = {
                /**
                    * Session ID.
                    */
                $id: string;
                /**
                    * Session creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Session update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Session expiration date in ISO 8601 format.
                    */
                expire: string;
                /**
                    * Session Provider.
                    */
                provider: string;
                /**
                    * Session Provider User ID.
                    */
                providerUid: string;
                /**
                    * Session Provider Access Token.
                    */
                providerAccessToken: string;
                /**
                    * The date of when the access token expires in ISO 8601 format.
                    */
                providerAccessTokenExpiry: string;
                /**
                    * Session Provider Refresh Token.
                    */
                providerRefreshToken: string;
                /**
                    * IP in use when the session was created.
                    */
                ip: string;
                /**
                    * Operating system code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/os.json).
                    */
                osCode: string;
                /**
                    * Operating system name.
                    */
                osName: string;
                /**
                    * Operating system version.
                    */
                osVersion: string;
                /**
                    * Client type.
                    */
                clientType: string;
                /**
                    * Client code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/clients.json).
                    */
                clientCode: string;
                /**
                    * Client name.
                    */
                clientName: string;
                /**
                    * Client version.
                    */
                clientVersion: string;
                /**
                    * Client engine name.
                    */
                clientEngine: string;
                /**
                    * Client engine name.
                    */
                clientEngineVersion: string;
                /**
                    * Device name.
                    */
                deviceName: string;
                /**
                    * Device brand name.
                    */
                deviceBrand: string;
                /**
                    * Device model name.
                    */
                deviceModel: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                countryCode: string;
                /**
                    * Country name.
                    */
                countryName: string;
                /**
                    * Returns true if this the current user session.
                    */
                current: boolean;
                /**
                    * Returns a list of active session factors.
                    */
                factors: string[];
                /**
                    * Secret used to authenticate the user. Only included if the request was made with an API key
                    */
                secret: string;
                /**
                    * Most recent date in ISO 8601 format when the session successfully passed MFA challenge.
                    */
                mfaUpdatedAt: string;
        };
        /**
            * Identity
            */
        type Identity = {
                /**
                    * Identity ID.
                    */
                $id: string;
                /**
                    * Identity creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Identity update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Identity Provider.
                    */
                provider: string;
                /**
                    * ID of the User in the Identity Provider.
                    */
                providerUid: string;
                /**
                    * Email of the User in the Identity Provider.
                    */
                providerEmail: string;
                /**
                    * Identity Provider Access Token.
                    */
                providerAccessToken: string;
                /**
                    * The date of when the access token expires in ISO 8601 format.
                    */
                providerAccessTokenExpiry: string;
                /**
                    * Identity Provider Refresh Token.
                    */
                providerRefreshToken: string;
        };
        /**
            * Token
            */
        type Token = {
                /**
                    * Token ID.
                    */
                $id: string;
                /**
                    * Token creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Token secret key. This will return an empty string unless the response is returned using an API key or as part of a webhook payload.
                    */
                secret: string;
                /**
                    * Token expiration date in ISO 8601 format.
                    */
                expire: string;
                /**
                    * Security phrase of a token. Empty if security phrase was not requested when creating a token. It includes randomly generated phrase which is also sent in the external resource such as email.
                    */
                phrase: string;
        };
        /**
            * JWT
            */
        type Jwt = {
                /**
                    * JWT encoded string.
                    */
                jwt: string;
        };
        /**
            * Locale
            */
        type Locale = {
                /**
                    * User IP address.
                    */
                ip: string;
                /**
                    * Country code in [ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1) two-character format
                    */
                countryCode: string;
                /**
                    * Country name. This field support localization.
                    */
                country: string;
                /**
                    * Continent code. A two character continent code &quot;AF&quot; for Africa, &quot;AN&quot; for Antarctica, &quot;AS&quot; for Asia, &quot;EU&quot; for Europe, &quot;NA&quot; for North America, &quot;OC&quot; for Oceania, and &quot;SA&quot; for South America.
                    */
                continentCode: string;
                /**
                    * Continent name. This field support localization.
                    */
                continent: string;
                /**
                    * True if country is part of the European Union.
                    */
                eu: boolean;
                /**
                    * Currency code in [ISO 4217-1](http://en.wikipedia.org/wiki/ISO_4217) three-character format
                    */
                currency: string;
        };
        /**
            * LocaleCode
            */
        type LocaleCode = {
                /**
                    * Locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)
                    */
                code: string;
                /**
                    * Locale name
                    */
                name: string;
        };
        /**
            * File
            */
        type File = {
                /**
                    * File ID.
                    */
                $id: string;
                /**
                    * Bucket ID.
                    */
                bucketId: string;
                /**
                    * File creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * File update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * File permissions. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                $permissions: string[];
                /**
                    * File name.
                    */
                name: string;
                /**
                    * File MD5 signature.
                    */
                signature: string;
                /**
                    * File mime type.
                    */
                mimeType: string;
                /**
                    * File original size in bytes.
                    */
                sizeOriginal: number;
                /**
                    * Total number of chunks available
                    */
                chunksTotal: number;
                /**
                    * Total number of chunks uploaded
                    */
                chunksUploaded: number;
        };
        /**
            * Team
            */
        type Team<Preferences extends Models.Preferences> = {
                /**
                    * Team ID.
                    */
                $id: string;
                /**
                    * Team creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Team update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Team name.
                    */
                name: string;
                /**
                    * Total number of team members.
                    */
                total: number;
                /**
                    * Team preferences as a key-value object
                    */
                prefs: Preferences;
        };
        /**
            * Membership
            */
        type Membership = {
                /**
                    * Membership ID.
                    */
                $id: string;
                /**
                    * Membership creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Membership update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * User name.
                    */
                userName: string;
                /**
                    * User email address.
                    */
                userEmail: string;
                /**
                    * Team ID.
                    */
                teamId: string;
                /**
                    * Team name.
                    */
                teamName: string;
                /**
                    * Date, the user has been invited to join the team in ISO 8601 format.
                    */
                invited: string;
                /**
                    * Date, the user has accepted the invitation to join the team in ISO 8601 format.
                    */
                joined: string;
                /**
                    * User confirmation status, true if the user has joined the team or false otherwise.
                    */
                confirm: boolean;
                /**
                    * Multi factor authentication status, true if the user has MFA enabled or false otherwise.
                    */
                mfa: boolean;
                /**
                    * User list of roles
                    */
                roles: string[];
        };
        /**
            * Execution
            */
        type Execution = {
                /**
                    * Execution ID.
                    */
                $id: string;
                /**
                    * Execution creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Execution upate date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Execution roles.
                    */
                $permissions: string[];
                /**
                    * Function ID.
                    */
                functionId: string;
                /**
                    * The trigger that caused the function to execute. Possible values can be: `http`, `schedule`, or `event`.
                    */
                trigger: string;
                /**
                    * The status of the function execution. Possible values can be: `waiting`, `processing`, `completed`, or `failed`.
                    */
                status: string;
                /**
                    * HTTP request method type.
                    */
                requestMethod: string;
                /**
                    * HTTP request path and query.
                    */
                requestPath: string;
                /**
                    * HTTP response headers as a key-value object. This will return only whitelisted headers. All headers are returned if execution is created as synchronous.
                    */
                requestHeaders: Headers[];
                /**
                    * HTTP response status code.
                    */
                responseStatusCode: number;
                /**
                    * HTTP response body. This will return empty unless execution is created as synchronous.
                    */
                responseBody: string;
                /**
                    * HTTP response headers as a key-value object. This will return only whitelisted headers. All headers are returned if execution is created as synchronous.
                    */
                responseHeaders: Headers[];
                /**
                    * Function logs. Includes the last 4,000 characters. This will return an empty string unless the response is returned using an API key or as part of a webhook payload.
                    */
                logs: string;
                /**
                    * Function errors. Includes the last 4,000 characters. This will return an empty string unless the response is returned using an API key or as part of a webhook payload.
                    */
                errors: string;
                /**
                    * Function execution duration in seconds.
                    */
                duration: number;
        };
        /**
            * Country
            */
        type Country = {
                /**
                    * Country name.
                    */
                name: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                code: string;
        };
        /**
            * Continent
            */
        type Continent = {
                /**
                    * Continent name.
                    */
                name: string;
                /**
                    * Continent two letter code.
                    */
                code: string;
        };
        /**
            * Language
            */
        type Language = {
                /**
                    * Language name.
                    */
                name: string;
                /**
                    * Language two-character ISO 639-1 codes.
                    */
                code: string;
                /**
                    * Language native name.
                    */
                nativeName: string;
        };
        /**
            * Currency
            */
        type Currency = {
                /**
                    * Currency symbol.
                    */
                symbol: string;
                /**
                    * Currency name.
                    */
                name: string;
                /**
                    * Currency native symbol.
                    */
                symbolNative: string;
                /**
                    * Number of decimal digits.
                    */
                decimalDigits: number;
                /**
                    * Currency digit rounding.
                    */
                rounding: number;
                /**
                    * Currency code in [ISO 4217-1](http://en.wikipedia.org/wiki/ISO_4217) three-character format.
                    */
                code: string;
                /**
                    * Currency plural name
                    */
                namePlural: string;
        };
        /**
            * Phone
            */
        type Phone = {
                /**
                    * Phone code.
                    */
                code: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                countryCode: string;
                /**
                    * Country name.
                    */
                countryName: string;
        };
        /**
            * Headers
            */
        type Headers = {
                /**
                    * Header name.
                    */
                name: string;
                /**
                    * Header value.
                    */
                value: string;
        };
        /**
            * MFA Challenge
            */
        type MfaChallenge = {
                /**
                    * Token ID.
                    */
                $id: string;
                /**
                    * Token creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Token expiration date in ISO 8601 format.
                    */
                expire: string;
        };
        /**
            * MFA Recovery Codes
            */
        type MfaRecoveryCodes = {
                /**
                    * Recovery codes.
                    */
                recoveryCodes: string[];
        };
        /**
            * MFAType
            */
        type MfaType = {
                /**
                    * Secret token used for TOTP factor.
                    */
                secret: string;
                /**
                    * URI for authenticator apps.
                    */
                uri: string;
        };
        /**
            * MFAFactors
            */
        type MfaFactors = {
                /**
                    * Can TOTP be used for MFA challenge for this account.
                    */
                totp: boolean;
                /**
                    * Can phone (SMS) be used for MFA challenge for this account.
                    */
                phone: boolean;
                /**
                    * Can email be used for MFA challenge for this account.
                    */
                email: boolean;
                /**
                    * Can recovery code be used for MFA challenge for this account.
                    */
                recoveryCode: boolean;
        };
        /**
            * Subscriber
            */
        type Subscriber = {
                /**
                    * Subscriber ID.
                    */
                $id: string;
                /**
                    * Subscriber creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Subscriber update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Target ID.
                    */
                targetId: string;
                /**
                    * Target.
                    */
                target: Target;
                /**
                    * Topic ID.
                    */
                userId: string;
                /**
                    * User Name.
                    */
                userName: string;
                /**
                    * Topic ID.
                    */
                topicId: string;
                /**
                    * The target provider type. Can be one of the following: `email`, `sms` or `push`.
                    */
                providerType: string;
        };
        /**
            * Target
            */
        type Target = {
                /**
                    * Target ID.
                    */
                $id: string;
                /**
                    * Target creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Target update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Target Name.
                    */
                name: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Provider ID.
                    */
                providerId?: string;
                /**
                    * The target provider type. Can be one of the following: `email`, `sms` or `push`.
                    */
                providerType: string;
                /**
                    * The target identifier.
                    */
                identifier: string;
        };
}

export class Service {
    static CHUNK_SIZE: number;
    client: Client;
    constructor(client: Client);
    static flatten(data: Payload, prefix?: string): Payload;
}

