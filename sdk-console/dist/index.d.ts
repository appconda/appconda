// Generated by dts-bundle v0.7.3

/**
  * Appconda Console SDK
  *
  * This SDK is compatible with Appconda server version 1.6.x.
  * For older versions, please check
  * [previous releases](https://github.com/appconda/sdk-for-console/releases).
  */

/**
    * Payload type representing a key-value pair with string keys and any values.
    */
type Payload = {
        [key: string]: any;
};
/**
    * Headers type representing a key-value pair with string keys and string values.
    */
type Headers = {
        [key: string]: string;
};
/**
    * Realtime event response structure with generic payload type.
    */
type RealtimeResponseEvent<T extends unknown> = {
        /**
            * List of event names associated with the response.
            */
        events: string[];
        /**
            * List of channel names associated with the response.
            */
        channels: string[];
        /**
            * Timestamp indicating the time of the event.
            */
        timestamp: number;
        /**
            * Payload containing event-specific data.
            */
        payload: T;
};
/**
    * Type representing upload progress information.
    */
type UploadProgress = {
        /**
            * Identifier for the upload progress.
            */
        $id: string;
        /**
            * Current progress of the upload (in percentage).
            */
        progress: number;
        /**
            * Total size uploaded (in bytes) during the upload process.
            */
        sizeUploaded: number;
        /**
            * Total number of chunks that need to be uploaded.
            */
        chunksTotal: number;
        /**
            * Number of chunks that have been successfully uploaded.
            */
        chunksUploaded: number;
};
/**
    * Exception thrown by the  package
    */
class AppcondaException extends Error {
        /**
            * The error code associated with the exception.
            */
        code: number;
        /**
            * The response string associated with the exception.
            */
        response: string;
        /**
            * Error type.
            * See [Error Types](https://appconda.io/docs/response-codes#errorTypes) for more information.
            */
        type: string;
        /**
            * Initializes a Appconda Exception.
            *
            * @param {string} message - The error message.
            * @param {number} code - The error code. Default is 0.
            * @param {string} type - The error type. Default is an empty string.
            * @param {string} response - The response string. Default is an empty string.
            */
        constructor(message: string, code?: number, type?: string, response?: string);
}
/**
    * Client that handles requests to Appconda
    */
class Client {
        static CHUNK_SIZE: number;
        /**
            * Holds configuration such as project.
            */
        config: {
                endpoint: string;
                endpointRealtime: string;
                project: string;
                key: string;
                jwt: string;
                locale: string;
                mode: string;
        };
        /**
            * Custom headers for API requests.
            */
        headers: Headers;
        /**
            * Set Endpoint
            *
            * Your project endpoint
            *
            * @param {string} endpoint
            *
            * @returns {this}
            */
        setEndpoint(endpoint: string): this;
        /**
            * Set Realtime Endpoint
            *
            * @param {string} endpointRealtime
            *
            * @returns {this}
            */
        setEndpointRealtime(endpointRealtime: string): this;
        /**
            * Set Project
            *
            * Your project ID
            *
            * @param value string
            *
            * @return {this}
            */
        setProject(value: string): this;
        /**
            * Set Key
            *
            * Your secret API key
            *
            * @param value string
            *
            * @return {this}
            */
        setKey(value: string): this;
        /**
            * Set JWT
            *
            * Your secret JSON Web Token
            *
            * @param value string
            *
            * @return {this}
            */
        setJWT(value: string): this;
        /**
            * Set Locale
            *
            * @param value string
            *
            * @return {this}
            */
        setLocale(value: string): this;
        /**
            * Set Mode
            *
            * @param value string
            *
            * @return {this}
            */
        setMode(value: string): this;
        /**
            * Subscribes to Appconda events and passes you the payload in realtime.
            *
            * @param {string|string[]} channels
            * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.
            *
            * Possible channels are:
            * - account
            * - collections
            * - collections.[ID]
            * - collections.[ID].documents
            * - documents
            * - documents.[ID]
            * - files
            * - files.[ID]
            * - executions
            * - executions.[ID]
            * - functions.[ID]
            * - teams
            * - teams.[ID]
            * - memberships
            * - memberships.[ID]
            * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.
            * @returns {() => void} Unsubscribes from events.
            */
        subscribe<T extends unknown>(channels: string | string[], callback: (payload: RealtimeResponseEvent<T>) => void): () => void;
        prepareRequest(method: string, url: URL, headers?: Headers, params?: Payload): {
                uri: string;
                options: RequestInit;
        };
        chunkedUpload(method: string, url: URL, headers: Headers, originalPayload: Payload, onProgress: (progress: UploadProgress) => void): Promise<any>;
        call(method: string, url: URL, headers?: Headers, params?: Payload, responseType?: string): Promise<any>;
        static flatten(data: Payload, prefix?: string): Payload;
}
export { Client, AppcondaException };
export type { Models, Payload, UploadProgress };
export type { RealtimeResponseEvent };

export class Account {
        client: Client;
        constructor(client: Client);
        /**
            * Get account
            *
            * Get the currently logged in user.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        get<Preferences extends Models.Preferences>(): Promise<Models.User<Preferences>>;
        /**
            * Create account
            *
            * Use this endpoint to allow a new user to register a new account in your project. After the user registration completes successfully, you can use the [/account/verfication](https://appconda.io/docs/references/cloud/client-web/account#createVerification) route to start verifying the user email address. To allow the new user to login to their new account, you need to create a new [account session](https://appconda.io/docs/references/cloud/client-web/account#createEmailSession).
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        create<Preferences extends Models.Preferences>(userId: string, email: string, password: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Delete account
            *
            * Delete the currently logged in user.
            *
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(): Promise<{}>;
        /**
            * Update email
            *
            * Update currently logged in user account email address. After changing user address, the user confirmation status will get reset. A new confirmation email is not sent automatically however you can use the send confirmation email endpoint again to send the confirmation email. For security measures, user password is required to complete this request.
This endpoint can also be used to convert an anonymous account to a normal one, by passing an email address and a new password.

            *
            * @param {string} email
            * @param {string} password
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateEmail<Preferences extends Models.Preferences>(email: string, password: string): Promise<Models.User<Preferences>>;
        /**
            * List Identities
            *
            * Get the list of identities for the currently logged in user.
            *
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.IdentityList>}
            */
        listIdentities(queries?: string[]): Promise<Models.IdentityList>;
        /**
            * Delete identity
            *
            * Delete an identity by its unique ID.
            *
            * @param {string} identityId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteIdentity(identityId: string): Promise<{}>;
        /**
            * Create JWT
            *
            * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appconda server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.Jwt>}
            */
        createJWT(): Promise<Models.Jwt>;
        /**
            * List logs
            *
            * Get the list of latest security activity logs for the currently logged in user. Each log returns user IP address, location and date and time of log.
            *
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listLogs(queries?: string[]): Promise<Models.LogList>;
        /**
            * Update MFA
            *
            * Enable or disable MFA on an account.
            *
            * @param {boolean} mfa
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateMFA<Preferences extends Models.Preferences>(mfa: boolean): Promise<Models.User<Preferences>>;
        /**
            * Create Authenticator
            *
            * Add an authenticator app to be used as an MFA factor. Verify the authenticator using the [verify authenticator](/docs/references/cloud/client-web/account#updateMfaAuthenticator) method.
            *
            * @param {AuthenticatorType} type
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaType>}
            */
        createMfaAuthenticator(type: AuthenticatorType): Promise<Models.MfaType>;
        /**
            * Verify Authenticator
            *
            * Verify an authenticator app after adding it using the [add authenticator](/docs/references/cloud/client-web/account#createMfaAuthenticator) method.
            *
            * @param {AuthenticatorType} type
            * @param {string} otp
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateMfaAuthenticator<Preferences extends Models.Preferences>(type: AuthenticatorType, otp: string): Promise<Models.User<Preferences>>;
        /**
            * Delete Authenticator
            *
            * Delete an authenticator for a user by ID.
            *
            * @param {AuthenticatorType} type
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteMfaAuthenticator(type: AuthenticatorType): Promise<{}>;
        /**
            * Create MFA Challenge
            *
            * Begin the process of MFA verification after sign-in. Finish the flow with [updateMfaChallenge](/docs/references/cloud/client-web/account#updateMfaChallenge) method.
            *
            * @param {AuthenticationFactor} factor
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaChallenge>}
            */
        createMfaChallenge(factor: AuthenticationFactor): Promise<Models.MfaChallenge>;
        /**
            * Create MFA Challenge (confirmation)
            *
            * Complete the MFA challenge by providing the one-time password. Finish the process of MFA verification by providing the one-time password. To begin the flow, use [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
            *
            * @param {string} challengeId
            * @param {string} otp
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        updateMfaChallenge(challengeId: string, otp: string): Promise<{}>;
        /**
            * List Factors
            *
            * List the factors available on the account to be used as a MFA challange.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaFactors>}
            */
        listMfaFactors(): Promise<Models.MfaFactors>;
        /**
            * Get MFA Recovery Codes
            *
            * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaRecoveryCodes>}
            */
        getMfaRecoveryCodes(): Promise<Models.MfaRecoveryCodes>;
        /**
            * Create MFA Recovery Codes
            *
            * Generate recovery codes as backup for MFA flow. It&#039;s recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaRecoveryCodes>}
            */
        createMfaRecoveryCodes(): Promise<Models.MfaRecoveryCodes>;
        /**
            * Regenerate MFA Recovery Codes
            *
            * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaRecoveryCodes>}
            */
        updateMfaRecoveryCodes(): Promise<Models.MfaRecoveryCodes>;
        /**
            * Update name
            *
            * Update currently logged in user account name.
            *
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateName<Preferences extends Models.Preferences>(name: string): Promise<Models.User<Preferences>>;
        /**
            * Update password
            *
            * Update currently logged in user password. For validation, user is required to pass in the new password, and the old password. For users created with OAuth, Team Invites and Magic URL, oldPassword is optional.
            *
            * @param {string} password
            * @param {string} oldPassword
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updatePassword<Preferences extends Models.Preferences>(password: string, oldPassword?: string): Promise<Models.User<Preferences>>;
        /**
            * Update phone
            *
            * Update the currently logged in user&#039;s phone number. After updating the phone number, the phone verification status will be reset. A confirmation SMS is not sent automatically, however you can use the [POST /account/verification/phone](https://appconda.io/docs/references/cloud/client-web/account#createPhoneVerification) endpoint to send a confirmation SMS.
            *
            * @param {string} phone
            * @param {string} password
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updatePhone<Preferences extends Models.Preferences>(phone: string, password: string): Promise<Models.User<Preferences>>;
        /**
            * Get account preferences
            *
            * Get the preferences as a key-value object for the currently logged in user.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Preferences>}
            */
        getPrefs<Preferences extends Models.Preferences>(): Promise<Preferences>;
        /**
            * Update preferences
            *
            * Update currently logged in user account preferences. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
            *
            * @param {Partial<Preferences>} prefs
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updatePrefs<Preferences extends Models.Preferences>(prefs: Partial<Preferences>): Promise<Models.User<Preferences>>;
        /**
            * Create password recovery
            *
            * Sends the user an email with a temporary secret key for password reset. When the user clicks the confirmation link he is redirected back to your app password reset URL with the secret key and email address values attached to the URL query string. Use the query string params to submit a request to the [PUT /account/recovery](https://appconda.io/docs/references/cloud/client-web/account#updateRecovery) endpoint to complete the process. The verification link sent to the user&#039;s email address is valid for 1 hour.
            *
            * @param {string} email
            * @param {string} url
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createRecovery(email: string, url: string): Promise<Models.Token>;
        /**
            * Create password recovery (confirmation)
            *
            * Use this endpoint to complete the user account password reset. Both the **userId** and **secret** arguments will be passed as query parameters to the redirect URL you have provided when sending your request to the [POST /account/recovery](https://appconda.io/docs/references/cloud/client-web/account#createRecovery) endpoint.

Please note that in order to avoid a [Redirect Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md) the only valid redirect URLs are the ones from domains you have set when adding your platforms in the console interface.
            *
            * @param {string} userId
            * @param {string} secret
            * @param {string} password
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        updateRecovery(userId: string, secret: string, password: string): Promise<Models.Token>;
        /**
            * List sessions
            *
            * Get the list of active sessions across different devices for the currently logged in user.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.SessionList>}
            */
        listSessions(): Promise<Models.SessionList>;
        /**
            * Delete sessions
            *
            * Delete all sessions from the user account and remove any sessions cookies from the end client.
            *
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteSessions(): Promise<{}>;
        /**
            * Create anonymous session
            *
            * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appconda.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appconda.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        createAnonymousSession(): Promise<Models.Session>;
        /**
            * Create email password session
            *
            * Allow the user to login into their account by providing a valid email and password combination. This route will create a new session for the user.

A user is limited to 10 active sessions at a time by default. [Learn more about session limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {string} email
            * @param {string} password
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        createEmailPasswordSession(email: string, password: string): Promise<Models.Session>;
        /**
            * Update magic URL session
            *
            * Use this endpoint to create a session from token. Provide the **userId** and **secret** parameters from the successful response of authentication flows initiated by token creation. For example, magic URL and phone login.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        updateMagicURLSession(userId: string, secret: string): Promise<Models.Session>;
        /**
            * Create OAuth2 session
            *
            * Allow the user to login to their account using the OAuth2 provider of their choice. Each OAuth2 provider should be enabled from the Appconda console first. Use the success and failure arguments to provide a redirect URL&#039;s back to your app when login is completed.

If there is already an active session, the new session will be attached to the logged-in account. If there are no active sessions, the server will attempt to look for a user with the same email address as the email received from the OAuth2 provider and attach the new session to the existing user. If no matching user is found - the server will create a new user.

A user is limited to 10 active sessions at a time by default. [Learn more about session limits](https://appconda.io/docs/authentication-security#limits).

            *
            * @param {OAuthProvider} provider
            * @param {string} success
            * @param {string} failure
            * @param {string[]} scopes
            * @throws {AppcondaException}
            * @returns {Promise<void | string>}
            */
        createOAuth2Session(provider: OAuthProvider, success?: string, failure?: string, scopes?: string[]): Promise<void | string>;
        /**
            * Update phone session
            *
            * Use this endpoint to create a session from token. Provide the **userId** and **secret** parameters from the successful response of authentication flows initiated by token creation. For example, magic URL and phone login.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        updatePhoneSession(userId: string, secret: string): Promise<Models.Session>;
        /**
            * Create session
            *
            * Use this endpoint to create a session from token. Provide the **userId** and **secret** parameters from the successful response of authentication flows initiated by token creation. For example, magic URL and phone login.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        createSession(userId: string, secret: string): Promise<Models.Session>;
        /**
            * Get session
            *
            * Use this endpoint to get a logged in user&#039;s session using a Session ID. Inputting &#039;current&#039; will return the current session being used.
            *
            * @param {string} sessionId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        getSession(sessionId: string): Promise<Models.Session>;
        /**
            * Update session
            *
            * Use this endpoint to extend a session&#039;s length. Extending a session is useful when session expiry is short. If the session was created using an OAuth provider, this endpoint refreshes the access token from the provider.
            *
            * @param {string} sessionId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        updateSession(sessionId: string): Promise<Models.Session>;
        /**
            * Delete session
            *
            * Logout the user. Use &#039;current&#039; as the session ID to logout on this device, use a session ID to logout on another device. If you&#039;re looking to logout the user on all devices, use [Delete Sessions](https://appconda.io/docs/references/cloud/client-web/account#deleteSessions) instead.
            *
            * @param {string} sessionId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteSession(sessionId: string): Promise<{}>;
        /**
            * Update status
            *
            * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateStatus<Preferences extends Models.Preferences>(): Promise<Models.User<Preferences>>;
        /**
            * Create push target
            *
            *
            * @param {string} targetId
            * @param {string} identifier
            * @param {string} providerId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Target>}
            */
        createPushTarget(targetId: string, identifier: string, providerId?: string): Promise<Models.Target>;
        /**
            * Update push target
            *
            *
            * @param {string} targetId
            * @param {string} identifier
            * @throws {AppcondaException}
            * @returns {Promise<Models.Target>}
            */
        updatePushTarget(targetId: string, identifier: string): Promise<Models.Target>;
        /**
            * Delete push target
            *
            *
            * @param {string} targetId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deletePushTarget(targetId: string): Promise<{}>;
        /**
            * Create email token (OTP)
            *
            * Sends the user an email with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [POST /v1/account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession) endpoint to complete the login process. The secret sent to the user&#039;s email is valid for 15 minutes.

A user is limited to 10 active sessions at a time by default. [Learn more about session limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {string} userId
            * @param {string} email
            * @param {boolean} phrase
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createEmailToken(userId: string, email: string, phrase?: boolean): Promise<Models.Token>;
        /**
            * Create magic URL token
            *
            * Sends the user an email with a secret key for creating a session. If the provided user ID has not been registered, a new user will be created. When the user clicks the link in the email, the user is redirected back to the URL you provided with the secret key and userId values attached to the URL query string. Use the query string parameters to submit a request to the [POST /v1/account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession) endpoint to complete the login process. The link sent to the user&#039;s email address is valid for 1 hour. If you are on a mobile device you can leave the URL parameter empty, so that the login completion will be handled by your Appconda instance by default.

A user is limited to 10 active sessions at a time by default. [Learn more about session limits](https://appconda.io/docs/authentication-security#limits).

            *
            * @param {string} userId
            * @param {string} email
            * @param {string} url
            * @param {boolean} phrase
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createMagicURLToken(userId: string, email: string, url?: string, phrase?: boolean): Promise<Models.Token>;
        /**
            * Create OAuth2 token
            *
            * Allow the user to login to their account using the OAuth2 provider of their choice. Each OAuth2 provider should be enabled from the Appconda console first. Use the success and failure arguments to provide a redirect URL&#039;s back to your app when login is completed.

If authentication succeeds, `userId` and `secret` of a token will be appended to the success URL as query parameters. These can be used to create a new session using the [Create session](https://appconda.io/docs/references/cloud/client-web/account#createSession) endpoint.

A user is limited to 10 active sessions at a time by default. [Learn more about session limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {OAuthProvider} provider
            * @param {string} success
            * @param {string} failure
            * @param {string[]} scopes
            * @throws {AppcondaException}
            * @returns {Promise<void | string>}
            */
        createOAuth2Token(provider: OAuthProvider, success?: string, failure?: string, scopes?: string[]): Promise<void | string>;
        /**
            * Create phone token
            *
            * Sends the user an SMS with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [POST /v1/account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession) endpoint to complete the login process. The secret sent to the user&#039;s phone is valid for 15 minutes.

A user is limited to 10 active sessions at a time by default. [Learn more about session limits](https://appconda.io/docs/authentication-security#limits).
            *
            * @param {string} userId
            * @param {string} phone
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createPhoneToken(userId: string, phone: string): Promise<Models.Token>;
        /**
            * Create email verification
            *
            * Use this endpoint to send a verification message to your user email address to confirm they are the valid owners of that address. Both the **userId** and **secret** arguments will be passed as query parameters to the URL you have provided to be attached to the verification email. The provided URL should redirect the user back to your app and allow you to complete the verification process by verifying both the **userId** and **secret** parameters. Learn more about how to [complete the verification process](https://appconda.io/docs/references/cloud/client-web/account#updateVerification). The verification link sent to the user&#039;s email address is valid for 7 days.

Please note that in order to avoid a [Redirect Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md), the only valid redirect URLs are the ones from domains you have set when adding your platforms in the console interface.

            *
            * @param {string} url
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createVerification(url: string): Promise<Models.Token>;
        /**
            * Create email verification (confirmation)
            *
            * Use this endpoint to complete the user email verification process. Use both the **userId** and **secret** parameters that were attached to your app URL to verify the user email ownership. If confirmed this route will return a 200 status code.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        updateVerification(userId: string, secret: string): Promise<Models.Token>;
        /**
            * Create phone verification
            *
            * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user&#039;s phone number using the [accountUpdatePhone](https://appconda.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appconda.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user&#039;s phone number is valid for 15 minutes.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createPhoneVerification(): Promise<Models.Token>;
        /**
            * Update phone verification (confirmation)
            *
            * Use this endpoint to complete the user phone verification process. Use the **userId** and **secret** that were sent to your user&#039;s phone number to verify the user email ownership. If confirmed this route will return a 200 status code.
            *
            * @param {string} userId
            * @param {string} secret
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        updatePhoneVerification(userId: string, secret: string): Promise<Models.Token>;
}

export class Avatars {
        client: Client;
        constructor(client: Client);
        /**
            * Get browser icon
            *
            * You can use this endpoint to show different browser icons to your users. The code argument receives the browser code as it appears in your user [GET /account/sessions](https://appconda.io/docs/references/cloud/client-web/account#getSessions) endpoint. Use width, height and quality arguments to change the output settings.

When one dimension is specified and the other is 0, the image is scaled with preserved aspect ratio. If both dimensions are 0, the API provides an image at source quality. If dimensions are not specified, the default size of image returned is 100x100px.
            *
            * @param {Browser} code
            * @param {number} width
            * @param {number} height
            * @param {number} quality
            * @throws {AppcondaException}
            * @returns {string}
            */
        getBrowser(code: Browser, width?: number, height?: number, quality?: number): string;
        /**
            * Get credit card icon
            *
            * The credit card endpoint will return you the icon of the credit card provider you need. Use width, height and quality arguments to change the output settings.

When one dimension is specified and the other is 0, the image is scaled with preserved aspect ratio. If both dimensions are 0, the API provides an image at source quality. If dimensions are not specified, the default size of image returned is 100x100px.

            *
            * @param {CreditCard} code
            * @param {number} width
            * @param {number} height
            * @param {number} quality
            * @throws {AppcondaException}
            * @returns {string}
            */
        getCreditCard(code: CreditCard, width?: number, height?: number, quality?: number): string;
        /**
            * Get favicon
            *
            * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote website URL.

This endpoint does not follow HTTP redirects.
            *
            * @param {string} url
            * @throws {AppcondaException}
            * @returns {string}
            */
        getFavicon(url: string): string;
        /**
            * Get country flag
            *
            * You can use this endpoint to show different country flags icons to your users. The code argument receives the 2 letter country code. Use width, height and quality arguments to change the output settings. Country codes follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.

When one dimension is specified and the other is 0, the image is scaled with preserved aspect ratio. If both dimensions are 0, the API provides an image at source quality. If dimensions are not specified, the default size of image returned is 100x100px.

            *
            * @param {Flag} code
            * @param {number} width
            * @param {number} height
            * @param {number} quality
            * @throws {AppcondaException}
            * @returns {string}
            */
        getFlag(code: Flag, width?: number, height?: number, quality?: number): string;
        /**
            * Get image from URL
            *
            * Use this endpoint to fetch a remote image URL and crop it to any image size you want. This endpoint is very useful if you need to crop and display remote images in your app or in case you want to make sure a 3rd party image is properly served using a TLS protocol.

When one dimension is specified and the other is 0, the image is scaled with preserved aspect ratio. If both dimensions are 0, the API provides an image at source quality. If dimensions are not specified, the default size of image returned is 400x400px.

This endpoint does not follow HTTP redirects.
            *
            * @param {string} url
            * @param {number} width
            * @param {number} height
            * @throws {AppcondaException}
            * @returns {string}
            */
        getImage(url: string, width?: number, height?: number): string;
        /**
            * Get user initials
            *
            * Use this endpoint to show your user initials avatar icon on your website or app. By default, this route will try to print your logged-in user name or email initials. You can also overwrite the user name if you pass the &#039;name&#039; parameter. If no name is given and no user is logged, an empty avatar will be returned.

You can use the color and background params to change the avatar colors. By default, a random theme will be selected. The random theme will persist for the user&#039;s initials when reloading the same theme will always return for the same initials.

When one dimension is specified and the other is 0, the image is scaled with preserved aspect ratio. If both dimensions are 0, the API provides an image at source quality. If dimensions are not specified, the default size of image returned is 100x100px.

            *
            * @param {string} name
            * @param {number} width
            * @param {number} height
            * @param {string} background
            * @throws {AppcondaException}
            * @returns {string}
            */
        getInitials(name?: string, width?: number, height?: number, background?: string): string;
        /**
            * Get QR code
            *
            * Converts a given plain text to a QR code image. You can use the query parameters to change the size and style of the resulting image.

            *
            * @param {string} text
            * @param {number} size
            * @param {number} margin
            * @param {boolean} download
            * @throws {AppcondaException}
            * @returns {string}
            */
        getQR(text: string, size?: number, margin?: number, download?: boolean): string;
}

export class Assistant {
    client: Client;
    constructor(client: Client);
    /**
      * Ask Query
      *
      *
      * @param {string} prompt
      * @throws {AppcondaException}
      * @returns {Promise<{}>}
      */
    chat(prompt: string): Promise<{}>;
}

export class Console {
    client: Client;
    constructor(client: Client);
    /**
      * Get variables
      *
      * Get all Environment Variables that are relevant for the console.
      *
      * @throws {AppcondaException}
      * @returns {Promise<Models.ConsoleVariables>}
      */
    variables(): Promise<Models.ConsoleVariables>;
}

export class Databases {
        client: Client;
        constructor(client: Client);
        /**
            * List databases
            *
            * Get a list of all databases from the current Appconda project. You can use the search parameter to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.DatabaseList>}
            */
        list(queries?: string[], search?: string): Promise<Models.DatabaseList>;
        /**
            * Create database
            *
            * Create a new Database.

            *
            * @param {string} databaseId
            * @param {string} name
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Database>}
            */
        create(databaseId: string, name: string, enabled?: boolean): Promise<Models.Database>;
        /**
            * Get databases usage stats
            *
            *
            * @param {DatabaseUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageDatabases>}
            */
        getUsage(range?: DatabaseUsageRange): Promise<Models.UsageDatabases>;
        /**
            * Get database
            *
            * Get a database by its unique ID. This endpoint response returns a JSON object with the database metadata.
            *
            * @param {string} databaseId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Database>}
            */
        get(databaseId: string): Promise<Models.Database>;
        /**
            * Update database
            *
            * Update a database by its unique ID.
            *
            * @param {string} databaseId
            * @param {string} name
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Database>}
            */
        update(databaseId: string, name: string, enabled?: boolean): Promise<Models.Database>;
        /**
            * Delete database
            *
            * Delete a database by its unique ID. Only API keys with with databases.write scope can delete a database.
            *
            * @param {string} databaseId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(databaseId: string): Promise<{}>;
        /**
            * List collections
            *
            * Get a list of all collections that belong to the provided databaseId. You can use the search parameter to filter your results.
            *
            * @param {string} databaseId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.CollectionList>}
            */
        listCollections(databaseId: string, queries?: string[], search?: string): Promise<Models.CollectionList>;
        /**
            * Create collection
            *
            * Create a new Collection. Before using this route, you should create a new database resource using either a [server integration](https://appconda.io/docs/server/databases#databasesCreateCollection) API or directly from your database console.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} name
            * @param {string[]} permissions
            * @param {boolean} documentSecurity
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Collection>}
            */
        createCollection(databaseId: string, collectionId: string, name: string, permissions?: string[], documentSecurity?: boolean, enabled?: boolean): Promise<Models.Collection>;
        /**
            * Get collection
            *
            * Get a collection by its unique ID. This endpoint response returns a JSON object with the collection metadata.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Collection>}
            */
        getCollection(databaseId: string, collectionId: string): Promise<Models.Collection>;
        /**
            * Update collection
            *
            * Update a collection by its unique ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} name
            * @param {string[]} permissions
            * @param {boolean} documentSecurity
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Collection>}
            */
        updateCollection(databaseId: string, collectionId: string, name: string, permissions?: string[], documentSecurity?: boolean, enabled?: boolean): Promise<Models.Collection>;
        /**
            * Delete collection
            *
            * Delete a collection by its unique ID. Only users with write permissions have access to delete this resource.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteCollection(databaseId: string, collectionId: string): Promise<{}>;
        /**
            * List attributes
            *
            * List attributes in the collection.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeList>}
            */
        listAttributes(databaseId: string, collectionId: string, queries?: string[]): Promise<Models.AttributeList>;
        /**
            * Create boolean attribute
            *
            * Create a boolean attribute.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {boolean} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeBoolean>}
            */
        createBooleanAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: boolean, array?: boolean): Promise<Models.AttributeBoolean>;
        /**
            * Update boolean attribute
            *
            * Update a boolean attribute. Changing the `default` value will not update already existing documents.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {boolean} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeBoolean>}
            */
        updateBooleanAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: boolean): Promise<Models.AttributeBoolean>;
        /**
            * Create datetime attribute
            *
            * Create a date time attribute according to the ISO 8601 standard.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeDatetime>}
            */
        createDatetimeAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string, array?: boolean): Promise<Models.AttributeDatetime>;
        /**
            * Update dateTime attribute
            *
            * Update a date time attribute. Changing the `default` value will not update already existing documents.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeDatetime>}
            */
        updateDatetimeAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string): Promise<Models.AttributeDatetime>;
        /**
            * Create email attribute
            *
            * Create an email attribute.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeEmail>}
            */
        createEmailAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string, array?: boolean): Promise<Models.AttributeEmail>;
        /**
            * Update email attribute
            *
            * Update an email attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeEmail>}
            */
        updateEmailAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string): Promise<Models.AttributeEmail>;
        /**
            * Create enum attribute
            *
            * Create an enumeration attribute. The `elements` param acts as a white-list of accepted values for this attribute.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {string[]} elements
            * @param {boolean} required
            * @param {string} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeEnum>}
            */
        createEnumAttribute(databaseId: string, collectionId: string, key: string, elements: string[], required: boolean, xdefault?: string, array?: boolean): Promise<Models.AttributeEnum>;
        /**
            * Update enum attribute
            *
            * Update an enum attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {string[]} elements
            * @param {boolean} required
            * @param {string} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeEnum>}
            */
        updateEnumAttribute(databaseId: string, collectionId: string, key: string, elements: string[], required: boolean, xdefault?: string): Promise<Models.AttributeEnum>;
        /**
            * Create float attribute
            *
            * Create a float attribute. Optionally, minimum and maximum values can be provided.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {number} min
            * @param {number} max
            * @param {number} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeFloat>}
            */
        createFloatAttribute(databaseId: string, collectionId: string, key: string, required: boolean, min?: number, max?: number, xdefault?: number, array?: boolean): Promise<Models.AttributeFloat>;
        /**
            * Update float attribute
            *
            * Update a float attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {number} min
            * @param {number} max
            * @param {number} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeFloat>}
            */
        updateFloatAttribute(databaseId: string, collectionId: string, key: string, required: boolean, min: number, max: number, xdefault?: number): Promise<Models.AttributeFloat>;
        /**
            * Create integer attribute
            *
            * Create an integer attribute. Optionally, minimum and maximum values can be provided.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {number} min
            * @param {number} max
            * @param {number} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeInteger>}
            */
        createIntegerAttribute(databaseId: string, collectionId: string, key: string, required: boolean, min?: number, max?: number, xdefault?: number, array?: boolean): Promise<Models.AttributeInteger>;
        /**
            * Update integer attribute
            *
            * Update an integer attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {number} min
            * @param {number} max
            * @param {number} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeInteger>}
            */
        updateIntegerAttribute(databaseId: string, collectionId: string, key: string, required: boolean, min: number, max: number, xdefault?: number): Promise<Models.AttributeInteger>;
        /**
            * Create IP address attribute
            *
            * Create IP address attribute.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeIp>}
            */
        createIpAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string, array?: boolean): Promise<Models.AttributeIp>;
        /**
            * Update IP address attribute
            *
            * Update an ip attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeIp>}
            */
        updateIpAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string): Promise<Models.AttributeIp>;
        /**
            * Create relationship attribute
            *
            * Create relationship attribute. [Learn more about relationship attributes](https://appconda.io/docs/databases-relationships#relationship-attributes).

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} relatedCollectionId
            * @param {RelationshipType} type
            * @param {boolean} twoWay
            * @param {string} key
            * @param {string} twoWayKey
            * @param {RelationMutate} onDelete
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeRelationship>}
            */
        createRelationshipAttribute(databaseId: string, collectionId: string, relatedCollectionId: string, type: RelationshipType, twoWay?: boolean, key?: string, twoWayKey?: string, onDelete?: RelationMutate): Promise<Models.AttributeRelationship>;
        /**
            * Create string attribute
            *
            * Create a string attribute.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {number} size
            * @param {boolean} required
            * @param {string} xdefault
            * @param {boolean} array
            * @param {boolean} encrypt
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeString>}
            */
        createStringAttribute(databaseId: string, collectionId: string, key: string, size: number, required: boolean, xdefault?: string, array?: boolean, encrypt?: boolean): Promise<Models.AttributeString>;
        /**
            * Update string attribute
            *
            * Update a string attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeString>}
            */
        updateStringAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string): Promise<Models.AttributeString>;
        /**
            * Create URL attribute
            *
            * Create a URL attribute.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @param {boolean} array
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeUrl>}
            */
        createUrlAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string, array?: boolean): Promise<Models.AttributeUrl>;
        /**
            * Update URL attribute
            *
            * Update an url attribute. Changing the `default` value will not update already existing documents.

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {boolean} required
            * @param {string} xdefault
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeUrl>}
            */
        updateUrlAttribute(databaseId: string, collectionId: string, key: string, required: boolean, xdefault?: string): Promise<Models.AttributeUrl>;
        /**
            * Get attribute
            *
            * Get attribute by ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        getAttribute(databaseId: string, collectionId: string, key: string): Promise<{}>;
        /**
            * Delete attribute
            *
            * Deletes an attribute.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteAttribute(databaseId: string, collectionId: string, key: string): Promise<{}>;
        /**
            * Update relationship attribute
            *
            * Update relationship attribute. [Learn more about relationship attributes](https://appconda.io/docs/databases-relationships#relationship-attributes).

            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {RelationMutate} onDelete
            * @throws {AppcondaException}
            * @returns {Promise<Models.AttributeRelationship>}
            */
        updateRelationshipAttribute(databaseId: string, collectionId: string, key: string, onDelete?: RelationMutate): Promise<Models.AttributeRelationship>;
        /**
            * List documents
            *
            * Get a list of all the user&#039;s documents in a given collection. You can use the query params to filter your results.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.DocumentList<Document>>}
            */
        listDocuments<Document extends Models.Document>(databaseId: string, collectionId: string, queries?: string[]): Promise<Models.DocumentList<Document>>;
        /**
            * Create document
            *
            * Create a new Document. Before using this route, you should create a new collection resource using either a [server integration](https://appconda.io/docs/server/databases#databasesCreateCollection) API or directly from your database console.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {Omit<Document, keyof Models.Document>} data
            * @param {string[]} permissions
            * @throws {AppcondaException}
            * @returns {Promise<Document>}
            */
        createDocument<Document extends Models.Document>(databaseId: string, collectionId: string, documentId: string, data: Omit<Document, keyof Models.Document>, permissions?: string[]): Promise<Document>;
        /**
            * Get document
            *
            * Get a document by its unique ID. This endpoint response returns a JSON object with the document data.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Document>}
            */
        getDocument<Document extends Models.Document>(databaseId: string, collectionId: string, documentId: string, queries?: string[]): Promise<Document>;
        /**
            * Update document
            *
            * Update a document by its unique ID. Using the patch method you can pass only specific fields that will get updated.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {Partial<Omit<Document, keyof Models.Document>>} data
            * @param {string[]} permissions
            * @throws {AppcondaException}
            * @returns {Promise<Document>}
            */
        updateDocument<Document extends Models.Document>(databaseId: string, collectionId: string, documentId: string, data?: Partial<Omit<Document, keyof Models.Document>>, permissions?: string[]): Promise<Document>;
        /**
            * Delete document
            *
            * Delete a document by its unique ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteDocument(databaseId: string, collectionId: string, documentId: string): Promise<{}>;
        /**
            * List document logs
            *
            * Get the document activity logs list by its unique ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} documentId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listDocumentLogs(databaseId: string, collectionId: string, documentId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List indexes
            *
            * List indexes in the collection.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.IndexList>}
            */
        listIndexes(databaseId: string, collectionId: string, queries?: string[]): Promise<Models.IndexList>;
        /**
            * Create index
            *
            * Creates an index on the attributes listed. Your index should include all the attributes you will query in a single request.
Attributes can be `key`, `fulltext`, and `unique`.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @param {IndexType} type
            * @param {string[]} attributes
            * @param {string[]} orders
            * @throws {AppcondaException}
            * @returns {Promise<Models.Index>}
            */
        createIndex(databaseId: string, collectionId: string, key: string, type: IndexType, attributes: string[], orders?: string[]): Promise<Models.Index>;
        /**
            * Get index
            *
            * Get index by ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @throws {AppcondaException}
            * @returns {Promise<Models.Index>}
            */
        getIndex(databaseId: string, collectionId: string, key: string): Promise<Models.Index>;
        /**
            * Delete index
            *
            * Delete an index.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string} key
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteIndex(databaseId: string, collectionId: string, key: string): Promise<{}>;
        /**
            * List collection logs
            *
            * Get the collection activity logs list by its unique ID.
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listCollectionLogs(databaseId: string, collectionId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * Get collection usage stats
            *
            *
            * @param {string} databaseId
            * @param {string} collectionId
            * @param {DatabaseUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageCollection>}
            */
        getCollectionUsage(databaseId: string, collectionId: string, range?: DatabaseUsageRange): Promise<Models.UsageCollection>;
        /**
            * List database logs
            *
            * Get the database activity logs list by its unique ID.
            *
            * @param {string} databaseId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listLogs(databaseId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * Get database usage stats
            *
            *
            * @param {string} databaseId
            * @param {DatabaseUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageDatabase>}
            */
        getDatabaseUsage(databaseId: string, range?: DatabaseUsageRange): Promise<Models.UsageDatabase>;
}

export class Functions {
        client: Client;
        constructor(client: Client);
        /**
            * List functions
            *
            * Get a list of all the project&#039;s functions. You can use the query params to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.FunctionList>}
            */
        list(queries?: string[], search?: string): Promise<Models.FunctionList>;
        /**
            * Create function
            *
            * Create a new function. You can pass a list of [permissions](https://appconda.io/docs/permissions) to allow different project users or team with access to execute the function using the client API.
            *
            * @param {string} functionId
            * @param {string} name
            * @param {Runtime} runtime
            * @param {string[]} execute
            * @param {string[]} events
            * @param {string} schedule
            * @param {number} timeout
            * @param {boolean} enabled
            * @param {boolean} logging
            * @param {string} entrypoint
            * @param {string} commands
            * @param {string[]} scopes
            * @param {string} installationId
            * @param {string} providerRepositoryId
            * @param {string} providerBranch
            * @param {boolean} providerSilentMode
            * @param {string} providerRootDirectory
            * @param {string} templateRepository
            * @param {string} templateOwner
            * @param {string} templateRootDirectory
            * @param {string} templateVersion
            * @param {string} specification
            * @throws {AppcondaException}
            * @returns {Promise<Models.Function>}
            */
        create(functionId: string, name: string, runtime: Runtime, execute?: string[], events?: string[], schedule?: string, timeout?: number, enabled?: boolean, logging?: boolean, entrypoint?: string, commands?: string, scopes?: string[], installationId?: string, providerRepositoryId?: string, providerBranch?: string, providerSilentMode?: boolean, providerRootDirectory?: string, templateRepository?: string, templateOwner?: string, templateRootDirectory?: string, templateVersion?: string, specification?: string): Promise<Models.Function>;
        /**
            * List runtimes
            *
            * Get a list of all runtimes that are currently active on your instance.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.RuntimeList>}
            */
        listRuntimes(): Promise<Models.RuntimeList>;
        /**
            * List available function runtime specifications
            *
            * List allowed function specifications for this instance.

            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.SpecificationList>}
            */
        listSpecifications(): Promise<Models.SpecificationList>;
        /**
            * List function templates
            *
            * List available function templates. You can use template details in [createFunction](/docs/references/cloud/server-nodejs/functions#create) method.
            *
            * @param {string[]} runtimes
            * @param {string[]} useCases
            * @param {number} limit
            * @param {number} offset
            * @throws {AppcondaException}
            * @returns {Promise<Models.TemplateFunctionList>}
            */
        listTemplates(runtimes?: string[], useCases?: string[], limit?: number, offset?: number): Promise<Models.TemplateFunctionList>;
        /**
            * Get function template
            *
            * Get a function template using ID. You can use template details in [createFunction](/docs/references/cloud/server-nodejs/functions#create) method.
            *
            * @param {string} templateId
            * @throws {AppcondaException}
            * @returns {Promise<Models.TemplateFunction>}
            */
        getTemplate(templateId: string): Promise<Models.TemplateFunction>;
        /**
            * Get functions usage
            *
            *
            * @param {FunctionUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageFunctions>}
            */
        getUsage(range?: FunctionUsageRange): Promise<Models.UsageFunctions>;
        /**
            * Get function
            *
            * Get a function by its unique ID.
            *
            * @param {string} functionId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Function>}
            */
        get(functionId: string): Promise<Models.Function>;
        /**
            * Update function
            *
            * Update function by its unique ID.
            *
            * @param {string} functionId
            * @param {string} name
            * @param {Runtime} runtime
            * @param {string[]} execute
            * @param {string[]} events
            * @param {string} schedule
            * @param {number} timeout
            * @param {boolean} enabled
            * @param {boolean} logging
            * @param {string} entrypoint
            * @param {string} commands
            * @param {string[]} scopes
            * @param {string} installationId
            * @param {string} providerRepositoryId
            * @param {string} providerBranch
            * @param {boolean} providerSilentMode
            * @param {string} providerRootDirectory
            * @param {string} specification
            * @throws {AppcondaException}
            * @returns {Promise<Models.Function>}
            */
        update(functionId: string, name: string, runtime?: Runtime, execute?: string[], events?: string[], schedule?: string, timeout?: number, enabled?: boolean, logging?: boolean, entrypoint?: string, commands?: string, scopes?: string[], installationId?: string, providerRepositoryId?: string, providerBranch?: string, providerSilentMode?: boolean, providerRootDirectory?: string, specification?: string): Promise<Models.Function>;
        /**
            * Delete function
            *
            * Delete a function by its unique ID.
            *
            * @param {string} functionId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(functionId: string): Promise<{}>;
        /**
            * List deployments
            *
            * Get a list of all the project&#039;s code deployments. You can use the query params to filter your results.
            *
            * @param {string} functionId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.DeploymentList>}
            */
        listDeployments(functionId: string, queries?: string[], search?: string): Promise<Models.DeploymentList>;
        /**
            * Create deployment
            *
            * Create a new function code deployment. Use this endpoint to upload a new version of your code function. To execute your newly uploaded code, you&#039;ll need to update the function&#039;s deployment to use your new deployment UID.

This endpoint accepts a tar.gz file compressed with your code. Make sure to include any dependencies your code has within the compressed file. You can learn more about code packaging in the [Appconda Cloud Functions tutorial](https://appconda.io/docs/functions).

Use the &quot;command&quot; param to set the entrypoint used to execute your code.
            *
            * @param {string} functionId
            * @param {File} code
            * @param {boolean} activate
            * @param {string} entrypoint
            * @param {string} commands
            * @throws {AppcondaException}
            * @returns {Promise<Models.Deployment>}
            */
        createDeployment(functionId: string, code: File, activate: boolean, entrypoint?: string, commands?: string, onProgress?: (progress: UploadProgress) => void): Promise<Models.Deployment>;
        /**
            * Get deployment
            *
            * Get a code deployment by its unique ID.
            *
            * @param {string} functionId
            * @param {string} deploymentId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Deployment>}
            */
        getDeployment(functionId: string, deploymentId: string): Promise<Models.Deployment>;
        /**
            * Update deployment
            *
            * Update the function code deployment ID using the unique function ID. Use this endpoint to switch the code deployment that should be executed by the execution endpoint.
            *
            * @param {string} functionId
            * @param {string} deploymentId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Function>}
            */
        updateDeployment(functionId: string, deploymentId: string): Promise<Models.Function>;
        /**
            * Delete deployment
            *
            * Delete a code deployment by its unique ID.
            *
            * @param {string} functionId
            * @param {string} deploymentId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteDeployment(functionId: string, deploymentId: string): Promise<{}>;
        /**
            * Rebuild deployment
            *
            *
            * @param {string} functionId
            * @param {string} deploymentId
            * @param {string} buildId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        createBuild(functionId: string, deploymentId: string, buildId?: string): Promise<{}>;
        /**
            * Cancel deployment
            *
            *
            * @param {string} functionId
            * @param {string} deploymentId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Build>}
            */
        updateDeploymentBuild(functionId: string, deploymentId: string): Promise<Models.Build>;
        /**
            * Download deployment
            *
            * Get a Deployment&#039;s contents by its unique ID. This endpoint supports range requests for partial or streaming file download.
            *
            * @param {string} functionId
            * @param {string} deploymentId
            * @throws {AppcondaException}
            * @returns {string}
            */
        getDeploymentDownload(functionId: string, deploymentId: string): string;
        /**
            * List executions
            *
            * Get a list of all the current user function execution logs. You can use the query params to filter your results.
            *
            * @param {string} functionId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.ExecutionList>}
            */
        listExecutions(functionId: string, queries?: string[], search?: string): Promise<Models.ExecutionList>;
        /**
            * Create execution
            *
            * Trigger a function execution. The returned object will return you the current execution status. You can ping the `Get Execution` endpoint to get updates on the current execution status. Once this endpoint is called, your function execution process will start asynchronously.
            *
            * @param {string} functionId
            * @param {string} body
            * @param {boolean} async
            * @param {string} xpath
            * @param {ExecutionMethod} method
            * @param {object} headers
            * @param {string} scheduledAt
            * @throws {AppcondaException}
            * @returns {Promise<Models.Execution>}
            */
        createExecution(functionId: string, body?: string, async?: boolean, xpath?: string, method?: ExecutionMethod, headers?: object, scheduledAt?: string): Promise<Models.Execution>;
        /**
            * Get execution
            *
            * Get a function execution log by its unique ID.
            *
            * @param {string} functionId
            * @param {string} executionId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Execution>}
            */
        getExecution(functionId: string, executionId: string): Promise<Models.Execution>;
        /**
            * Delete execution
            *
            * Delete a function execution by its unique ID.

            *
            * @param {string} functionId
            * @param {string} executionId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteExecution(functionId: string, executionId: string): Promise<{}>;
        /**
            * Get function usage
            *
            *
            * @param {string} functionId
            * @param {FunctionUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageFunction>}
            */
        getFunctionUsage(functionId: string, range?: FunctionUsageRange): Promise<Models.UsageFunction>;
        /**
            * List variables
            *
            * Get a list of all variables of a specific function.
            *
            * @param {string} functionId
            * @throws {AppcondaException}
            * @returns {Promise<Models.VariableList>}
            */
        listVariables(functionId: string): Promise<Models.VariableList>;
        /**
            * Create variable
            *
            * Create a new function environment variable. These variables can be accessed in the function at runtime as environment variables.
            *
            * @param {string} functionId
            * @param {string} key
            * @param {string} value
            * @throws {AppcondaException}
            * @returns {Promise<Models.Variable>}
            */
        createVariable(functionId: string, key: string, value: string): Promise<Models.Variable>;
        /**
            * Get variable
            *
            * Get a variable by its unique ID.
            *
            * @param {string} functionId
            * @param {string} variableId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Variable>}
            */
        getVariable(functionId: string, variableId: string): Promise<Models.Variable>;
        /**
            * Update variable
            *
            * Update variable by its unique ID.
            *
            * @param {string} functionId
            * @param {string} variableId
            * @param {string} key
            * @param {string} value
            * @throws {AppcondaException}
            * @returns {Promise<Models.Variable>}
            */
        updateVariable(functionId: string, variableId: string, key: string, value?: string): Promise<Models.Variable>;
        /**
            * Delete variable
            *
            * Delete a variable by its unique ID.
            *
            * @param {string} functionId
            * @param {string} variableId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteVariable(functionId: string, variableId: string): Promise<{}>;
}

export class Graphql {
        client: Client;
        constructor(client: Client);
        /**
            * GraphQL endpoint
            *
            * Execute a GraphQL mutation.
            *
            * @param {object} query
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        query(query: object): Promise<{}>;
        /**
            * GraphQL endpoint
            *
            * Execute a GraphQL mutation.
            *
            * @param {object} query
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        mutation(query: object): Promise<{}>;
}

export class Health {
        client: Client;
        constructor(client: Client);
        /**
            * Get HTTP
            *
            * Check the Appconda HTTP server is up and responsive.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        get(): Promise<Models.HealthStatus>;
        /**
            * Get antivirus
            *
            * Check the Appconda Antivirus server is up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthAntivirus>}
            */
        getAntivirus(): Promise<Models.HealthAntivirus>;
        /**
            * Get cache
            *
            * Check the Appconda in-memory cache servers are up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        getCache(): Promise<Models.HealthStatus>;
        /**
            * Get the SSL certificate for a domain
            *
            * Get the SSL certificate for a domain
            *
            * @param {string} domain
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthCertificate>}
            */
        getCertificate(domain?: string): Promise<Models.HealthCertificate>;
        /**
            * Get DB
            *
            * Check the Appconda database servers are up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        getDB(): Promise<Models.HealthStatus>;
        /**
            * Get pubsub
            *
            * Check the Appconda pub-sub servers are up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        getPubSub(): Promise<Models.HealthStatus>;
        /**
            * Get queue
            *
            * Check the Appconda queue messaging servers are up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        getQueue(): Promise<Models.HealthStatus>;
        /**
            * Get builds queue
            *
            * Get the number of builds that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueBuilds(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get certificates queue
            *
            * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueCertificates(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get databases queue
            *
            * Get the number of database changes that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {string} name
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueDatabases(name?: string, threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get deletes queue
            *
            * Get the number of background destructive changes that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueDeletes(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get number of failed queue jobs
            *
            * Returns the amount of failed jobs in a given queue.

            *
            * @param {Name} name
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getFailedJobs(name: Name, threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get functions queue
            *
            * Get the number of function executions that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueFunctions(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get logs queue
            *
            * Get the number of logs that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueLogs(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get mails queue
            *
            * Get the number of mails that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueMails(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get messaging queue
            *
            * Get the number of messages that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueMessaging(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get migrations queue
            *
            * Get the number of migrations that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueMigrations(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get usage queue
            *
            * Get the number of metrics that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueUsage(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get usage dump queue
            *
            * Get the number of projects containing metrics that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueUsageDump(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get webhooks queue
            *
            * Get the number of webhooks that are waiting to be processed in the Appconda internal queue server.
            *
            * @param {number} threshold
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthQueue>}
            */
        getQueueWebhooks(threshold?: number): Promise<Models.HealthQueue>;
        /**
            * Get storage
            *
            * Check the Appconda storage device is up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        getStorage(): Promise<Models.HealthStatus>;
        /**
            * Get local storage
            *
            * Check the Appconda local storage device is up and connection is successful.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthStatus>}
            */
        getStorageLocal(): Promise<Models.HealthStatus>;
        /**
            * Get time
            *
            * Check the Appconda server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.HealthTime>}
            */
        getTime(): Promise<Models.HealthTime>;
}

export class Locale {
        client: Client;
        constructor(client: Client);
        /**
            * Get user locale
            *
            * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.

([IP Geolocation by DB-IP](https://db-ip.com))
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.Locale>}
            */
        get(): Promise<Models.Locale>;
        /**
            * List Locale Codes
            *
            * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.LocaleCodeList>}
            */
        listCodes(): Promise<Models.LocaleCodeList>;
        /**
            * List continents
            *
            * List of all continents. You can use the locale header to get the data in a supported language.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.ContinentList>}
            */
        listContinents(): Promise<Models.ContinentList>;
        /**
            * List countries
            *
            * List of all countries. You can use the locale header to get the data in a supported language.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.CountryList>}
            */
        listCountries(): Promise<Models.CountryList>;
        /**
            * List EU countries
            *
            * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.CountryList>}
            */
        listCountriesEU(): Promise<Models.CountryList>;
        /**
            * List countries phone codes
            *
            * List of all countries phone codes. You can use the locale header to get the data in a supported language.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.PhoneList>}
            */
        listCountriesPhones(): Promise<Models.PhoneList>;
        /**
            * List currencies
            *
            * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.CurrencyList>}
            */
        listCurrencies(): Promise<Models.CurrencyList>;
        /**
            * List languages
            *
            * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.LanguageList>}
            */
        listLanguages(): Promise<Models.LanguageList>;
}

export class Messaging {
        client: Client;
        constructor(client: Client);
        /**
            * List messages
            *
            * Get a list of all messages from the current Appconda project.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.MessageList>}
            */
        listMessages(queries?: string[], search?: string): Promise<Models.MessageList>;
        /**
            * Create email
            *
            * Create a new email message.
            *
            * @param {string} messageId
            * @param {string} subject
            * @param {string} content
            * @param {string[]} topics
            * @param {string[]} users
            * @param {string[]} targets
            * @param {string[]} cc
            * @param {string[]} bcc
            * @param {string[]} attachments
            * @param {boolean} draft
            * @param {boolean} html
            * @param {string} scheduledAt
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        createEmail(messageId: string, subject: string, content: string, topics?: string[], users?: string[], targets?: string[], cc?: string[], bcc?: string[], attachments?: string[], draft?: boolean, html?: boolean, scheduledAt?: string): Promise<Models.Message>;
        /**
            * Update email
            *
            * Update an email message by its unique ID.

            *
            * @param {string} messageId
            * @param {string[]} topics
            * @param {string[]} users
            * @param {string[]} targets
            * @param {string} subject
            * @param {string} content
            * @param {boolean} draft
            * @param {boolean} html
            * @param {string[]} cc
            * @param {string[]} bcc
            * @param {string} scheduledAt
            * @param {string[]} attachments
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        updateEmail(messageId: string, topics?: string[], users?: string[], targets?: string[], subject?: string, content?: string, draft?: boolean, html?: boolean, cc?: string[], bcc?: string[], scheduledAt?: string, attachments?: string[]): Promise<Models.Message>;
        /**
            * Create push notification
            *
            * Create a new push notification.
            *
            * @param {string} messageId
            * @param {string} title
            * @param {string} body
            * @param {string[]} topics
            * @param {string[]} users
            * @param {string[]} targets
            * @param {object} data
            * @param {string} action
            * @param {string} image
            * @param {string} icon
            * @param {string} sound
            * @param {string} color
            * @param {string} tag
            * @param {string} badge
            * @param {boolean} draft
            * @param {string} scheduledAt
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        createPush(messageId: string, title: string, body: string, topics?: string[], users?: string[], targets?: string[], data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: string, draft?: boolean, scheduledAt?: string): Promise<Models.Message>;
        /**
            * Update push notification
            *
            * Update a push notification by its unique ID.

            *
            * @param {string} messageId
            * @param {string[]} topics
            * @param {string[]} users
            * @param {string[]} targets
            * @param {string} title
            * @param {string} body
            * @param {object} data
            * @param {string} action
            * @param {string} image
            * @param {string} icon
            * @param {string} sound
            * @param {string} color
            * @param {string} tag
            * @param {number} badge
            * @param {boolean} draft
            * @param {string} scheduledAt
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        updatePush(messageId: string, topics?: string[], users?: string[], targets?: string[], title?: string, body?: string, data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string): Promise<Models.Message>;
        /**
            * Create SMS
            *
            * Create a new SMS message.
            *
            * @param {string} messageId
            * @param {string} content
            * @param {string[]} topics
            * @param {string[]} users
            * @param {string[]} targets
            * @param {boolean} draft
            * @param {string} scheduledAt
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        createSms(messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string): Promise<Models.Message>;
        /**
            * Update SMS
            *
            * Update an email message by its unique ID.

            *
            * @param {string} messageId
            * @param {string[]} topics
            * @param {string[]} users
            * @param {string[]} targets
            * @param {string} content
            * @param {boolean} draft
            * @param {string} scheduledAt
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        updateSms(messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string): Promise<Models.Message>;
        /**
            * Get message
            *
            * Get a message by its unique ID.

            *
            * @param {string} messageId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Message>}
            */
        getMessage(messageId: string): Promise<Models.Message>;
        /**
            * Delete message
            *
            * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.
            *
            * @param {string} messageId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(messageId: string): Promise<{}>;
        /**
            * List message logs
            *
            * Get the message activity logs listed by its unique ID.
            *
            * @param {string} messageId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listMessageLogs(messageId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List message targets
            *
            * Get a list of the targets associated with a message.
            *
            * @param {string} messageId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.TargetList>}
            */
        listTargets(messageId: string, queries?: string[]): Promise<Models.TargetList>;
        /**
            * List providers
            *
            * Get a list of all providers from the current Appconda project.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProviderList>}
            */
        listProviders(queries?: string[], search?: string): Promise<Models.ProviderList>;
        /**
            * Create APNS provider
            *
            * Create a new Apple Push Notification service provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} authKey
            * @param {string} authKeyId
            * @param {string} teamId
            * @param {string} bundleId
            * @param {boolean} sandbox
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createApnsProvider(providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update APNS provider
            *
            * Update a Apple Push Notification service provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} authKey
            * @param {string} authKeyId
            * @param {string} teamId
            * @param {string} bundleId
            * @param {boolean} sandbox
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateApnsProvider(providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean): Promise<Models.Provider>;
        /**
            * Create FCM provider
            *
            * Create a new Firebase Cloud Messaging provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {object} serviceAccountJSON
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createFcmProvider(providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update FCM provider
            *
            * Update a Firebase Cloud Messaging provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {object} serviceAccountJSON
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateFcmProvider(providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object): Promise<Models.Provider>;
        /**
            * Create Mailgun provider
            *
            * Create a new Mailgun provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} apiKey
            * @param {string} domain
            * @param {boolean} isEuRegion
            * @param {string} fromName
            * @param {string} fromEmail
            * @param {string} replyToName
            * @param {string} replyToEmail
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createMailgunProvider(providerId: string, name: string, apiKey?: string, domain?: string, isEuRegion?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Mailgun provider
            *
            * Update a Mailgun provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} apiKey
            * @param {string} domain
            * @param {boolean} isEuRegion
            * @param {boolean} enabled
            * @param {string} fromName
            * @param {string} fromEmail
            * @param {string} replyToName
            * @param {string} replyToEmail
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateMailgunProvider(providerId: string, name?: string, apiKey?: string, domain?: string, isEuRegion?: boolean, enabled?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string): Promise<Models.Provider>;
        /**
            * Create Msg91 provider
            *
            * Create a new MSG91 provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} templateId
            * @param {string} senderId
            * @param {string} authKey
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createMsg91Provider(providerId: string, name: string, templateId?: string, senderId?: string, authKey?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Msg91 provider
            *
            * Update a MSG91 provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} templateId
            * @param {string} senderId
            * @param {string} authKey
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateMsg91Provider(providerId: string, name?: string, enabled?: boolean, templateId?: string, senderId?: string, authKey?: string): Promise<Models.Provider>;
        /**
            * Create Sendgrid provider
            *
            * Create a new Sendgrid provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} apiKey
            * @param {string} fromName
            * @param {string} fromEmail
            * @param {string} replyToName
            * @param {string} replyToEmail
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createSendgridProvider(providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Sendgrid provider
            *
            * Update a Sendgrid provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} apiKey
            * @param {string} fromName
            * @param {string} fromEmail
            * @param {string} replyToName
            * @param {string} replyToEmail
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateSendgridProvider(providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string): Promise<Models.Provider>;
        /**
            * Create SMTP provider
            *
            * Create a new SMTP provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} host
            * @param {number} port
            * @param {string} username
            * @param {string} password
            * @param {SmtpEncryption} encryption
            * @param {boolean} autoTLS
            * @param {string} mailer
            * @param {string} fromName
            * @param {string} fromEmail
            * @param {string} replyToName
            * @param {string} replyToEmail
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createSmtpProvider(providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update SMTP provider
            *
            * Update a SMTP provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} host
            * @param {number} port
            * @param {string} username
            * @param {string} password
            * @param {SmtpEncryption} encryption
            * @param {boolean} autoTLS
            * @param {string} mailer
            * @param {string} fromName
            * @param {string} fromEmail
            * @param {string} replyToName
            * @param {string} replyToEmail
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateSmtpProvider(providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Create Telesign provider
            *
            * Create a new Telesign provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} from
            * @param {string} customerId
            * @param {string} apiKey
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createTelesignProvider(providerId: string, name: string, from?: string, customerId?: string, apiKey?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Telesign provider
            *
            * Update a Telesign provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} customerId
            * @param {string} apiKey
            * @param {string} from
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateTelesignProvider(providerId: string, name?: string, enabled?: boolean, customerId?: string, apiKey?: string, from?: string): Promise<Models.Provider>;
        /**
            * Create Textmagic provider
            *
            * Create a new Textmagic provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} from
            * @param {string} username
            * @param {string} apiKey
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createTextmagicProvider(providerId: string, name: string, from?: string, username?: string, apiKey?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Textmagic provider
            *
            * Update a Textmagic provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} username
            * @param {string} apiKey
            * @param {string} from
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateTextmagicProvider(providerId: string, name?: string, enabled?: boolean, username?: string, apiKey?: string, from?: string): Promise<Models.Provider>;
        /**
            * Create Twilio provider
            *
            * Create a new Twilio provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} from
            * @param {string} accountSid
            * @param {string} authToken
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createTwilioProvider(providerId: string, name: string, from?: string, accountSid?: string, authToken?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Twilio provider
            *
            * Update a Twilio provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} accountSid
            * @param {string} authToken
            * @param {string} from
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateTwilioProvider(providerId: string, name?: string, enabled?: boolean, accountSid?: string, authToken?: string, from?: string): Promise<Models.Provider>;
        /**
            * Create Vonage provider
            *
            * Create a new Vonage provider.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {string} from
            * @param {string} apiKey
            * @param {string} apiSecret
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        createVonageProvider(providerId: string, name: string, from?: string, apiKey?: string, apiSecret?: string, enabled?: boolean): Promise<Models.Provider>;
        /**
            * Update Vonage provider
            *
            * Update a Vonage provider by its unique ID.
            *
            * @param {string} providerId
            * @param {string} name
            * @param {boolean} enabled
            * @param {string} apiKey
            * @param {string} apiSecret
            * @param {string} from
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        updateVonageProvider(providerId: string, name?: string, enabled?: boolean, apiKey?: string, apiSecret?: string, from?: string): Promise<Models.Provider>;
        /**
            * Get provider
            *
            * Get a provider by its unique ID.

            *
            * @param {string} providerId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Provider>}
            */
        getProvider(providerId: string): Promise<Models.Provider>;
        /**
            * Delete provider
            *
            * Delete a provider by its unique ID.
            *
            * @param {string} providerId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteProvider(providerId: string): Promise<{}>;
        /**
            * List provider logs
            *
            * Get the provider activity logs listed by its unique ID.
            *
            * @param {string} providerId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listProviderLogs(providerId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List subscriber logs
            *
            * Get the subscriber activity logs listed by its unique ID.
            *
            * @param {string} subscriberId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listSubscriberLogs(subscriberId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List topics
            *
            * Get a list of all topics from the current Appconda project.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.TopicList>}
            */
        listTopics(queries?: string[], search?: string): Promise<Models.TopicList>;
        /**
            * Create topic
            *
            * Create a new topic.
            *
            * @param {string} topicId
            * @param {string} name
            * @param {string[]} subscribe
            * @throws {AppcondaException}
            * @returns {Promise<Models.Topic>}
            */
        createTopic(topicId: string, name: string, subscribe?: string[]): Promise<Models.Topic>;
        /**
            * Get topic
            *
            * Get a topic by its unique ID.

            *
            * @param {string} topicId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Topic>}
            */
        getTopic(topicId: string): Promise<Models.Topic>;
        /**
            * Update topic
            *
            * Update a topic by its unique ID.

            *
            * @param {string} topicId
            * @param {string} name
            * @param {string[]} subscribe
            * @throws {AppcondaException}
            * @returns {Promise<Models.Topic>}
            */
        updateTopic(topicId: string, name?: string, subscribe?: string[]): Promise<Models.Topic>;
        /**
            * Delete topic
            *
            * Delete a topic by its unique ID.
            *
            * @param {string} topicId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteTopic(topicId: string): Promise<{}>;
        /**
            * List topic logs
            *
            * Get the topic activity logs listed by its unique ID.
            *
            * @param {string} topicId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listTopicLogs(topicId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List subscribers
            *
            * Get a list of all subscribers from the current Appconda project.
            *
            * @param {string} topicId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.SubscriberList>}
            */
        listSubscribers(topicId: string, queries?: string[], search?: string): Promise<Models.SubscriberList>;
        /**
            * Create subscriber
            *
            * Create a new subscriber.
            *
            * @param {string} topicId
            * @param {string} subscriberId
            * @param {string} targetId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Subscriber>}
            */
        createSubscriber(topicId: string, subscriberId: string, targetId: string): Promise<Models.Subscriber>;
        /**
            * Get subscriber
            *
            * Get a subscriber by its unique ID.

            *
            * @param {string} topicId
            * @param {string} subscriberId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Subscriber>}
            */
        getSubscriber(topicId: string, subscriberId: string): Promise<Models.Subscriber>;
        /**
            * Delete subscriber
            *
            * Delete a subscriber by its unique ID.
            *
            * @param {string} topicId
            * @param {string} subscriberId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteSubscriber(topicId: string, subscriberId: string): Promise<{}>;
}

export class Migrations {
        client: Client;
        constructor(client: Client);
        /**
            * List Migrations
            *
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.MigrationList>}
            */
        list(queries?: string[], search?: string): Promise<Models.MigrationList>;
        /**
            * Migrate Appconda Data
            *
            *
            * @param {string[]} resources
            * @param {string} endpoint
            * @param {string} projectId
            * @param {string} apiKey
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        createAppwriteMigration(resources: string[], endpoint: string, projectId: string, apiKey: string): Promise<Models.Migration>;
        /**
            * Generate a report on Appconda Data
            *
            *
            * @param {string[]} resources
            * @param {string} endpoint
            * @param {string} projectID
            * @param {string} key
            * @throws {AppcondaException}
            * @returns {Promise<Models.MigrationReport>}
            */
        getAppwriteReport(resources: string[], endpoint: string, projectID: string, key: string): Promise<Models.MigrationReport>;
        /**
            * Migrate Firebase Data (Service Account)
            *
            *
            * @param {string[]} resources
            * @param {string} serviceAccount
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        createFirebaseMigration(resources: string[], serviceAccount: string): Promise<Models.Migration>;
        /**
            * Revoke Appconda&#039;s authorization to access Firebase Projects
            *
            *
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteFirebaseAuth(): Promise<{}>;
        /**
            * Migrate Firebase Data (OAuth)
            *
            *
            * @param {string[]} resources
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        createFirebaseOAuthMigration(resources: string[], projectId: string): Promise<Models.Migration>;
        /**
            * List Firebase Projects
            *
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.FirebaseProjectList>}
            */
        listFirebaseProjects(): Promise<Models.FirebaseProjectList>;
        /**
            * Generate a report on Firebase Data
            *
            *
            * @param {string[]} resources
            * @param {string} serviceAccount
            * @throws {AppcondaException}
            * @returns {Promise<Models.MigrationReport>}
            */
        getFirebaseReport(resources: string[], serviceAccount: string): Promise<Models.MigrationReport>;
        /**
            * Generate a report on Firebase Data using OAuth
            *
            *
            * @param {string[]} resources
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<Models.MigrationReport>}
            */
        getFirebaseReportOAuth(resources: string[], projectId: string): Promise<Models.MigrationReport>;
        /**
            * Migrate NHost Data
            *
            *
            * @param {string[]} resources
            * @param {string} subdomain
            * @param {string} region
            * @param {string} adminSecret
            * @param {string} database
            * @param {string} username
            * @param {string} password
            * @param {number} port
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        createNHostMigration(resources: string[], subdomain: string, region: string, adminSecret: string, database: string, username: string, password: string, port?: number): Promise<Models.Migration>;
        /**
            * Generate a report on NHost Data
            *
            *
            * @param {string[]} resources
            * @param {string} subdomain
            * @param {string} region
            * @param {string} adminSecret
            * @param {string} database
            * @param {string} username
            * @param {string} password
            * @param {number} port
            * @throws {AppcondaException}
            * @returns {Promise<Models.MigrationReport>}
            */
        getNHostReport(resources: string[], subdomain: string, region: string, adminSecret: string, database: string, username: string, password: string, port?: number): Promise<Models.MigrationReport>;
        /**
            * Migrate Supabase Data
            *
            *
            * @param {string[]} resources
            * @param {string} endpoint
            * @param {string} apiKey
            * @param {string} databaseHost
            * @param {string} username
            * @param {string} password
            * @param {number} port
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        createSupabaseMigration(resources: string[], endpoint: string, apiKey: string, databaseHost: string, username: string, password: string, port?: number): Promise<Models.Migration>;
        /**
            * Generate a report on Supabase Data
            *
            *
            * @param {string[]} resources
            * @param {string} endpoint
            * @param {string} apiKey
            * @param {string} databaseHost
            * @param {string} username
            * @param {string} password
            * @param {number} port
            * @throws {AppcondaException}
            * @returns {Promise<Models.MigrationReport>}
            */
        getSupabaseReport(resources: string[], endpoint: string, apiKey: string, databaseHost: string, username: string, password: string, port?: number): Promise<Models.MigrationReport>;
        /**
            * Get Migration
            *
            *
            * @param {string} migrationId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        get(migrationId: string): Promise<Models.Migration>;
        /**
            * Retry Migration
            *
            *
            * @param {string} migrationId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Migration>}
            */
        retry(migrationId: string): Promise<Models.Migration>;
        /**
            * Delete Migration
            *
            *
            * @param {string} migrationId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(migrationId: string): Promise<{}>;
}

export class Project {
        client: Client;
        constructor(client: Client);
        /**
            * Get project usage stats
            *
            *
            * @param {string} startDate
            * @param {string} endDate
            * @param {ProjectUsageRange} period
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageProject>}
            */
        getUsage(startDate: string, endDate: string, period?: ProjectUsageRange): Promise<Models.UsageProject>;
        /**
            * List Variables
            *
            * Get a list of all project variables. These variables will be accessible in all Appconda Functions at runtime.
            *
            * @throws {AppcondaException}
            * @returns {Promise<Models.VariableList>}
            */
        listVariables(): Promise<Models.VariableList>;
        /**
            * Create Variable
            *
            * Create a new project variable. This variable will be accessible in all Appconda Functions at runtime.
            *
            * @param {string} key
            * @param {string} value
            * @throws {AppcondaException}
            * @returns {Promise<Models.Variable>}
            */
        createVariable(key: string, value: string): Promise<Models.Variable>;
        /**
            * Get Variable
            *
            * Get a project variable by its unique ID.
            *
            * @param {string} variableId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Variable>}
            */
        getVariable(variableId: string): Promise<Models.Variable>;
        /**
            * Update Variable
            *
            * Update project variable by its unique ID. This variable will be accessible in all Appconda Functions at runtime.
            *
            * @param {string} variableId
            * @param {string} key
            * @param {string} value
            * @throws {AppcondaException}
            * @returns {Promise<Models.Variable>}
            */
        updateVariable(variableId: string, key: string, value?: string): Promise<Models.Variable>;
        /**
            * Delete Variable
            *
            * Delete a project variable by its unique ID.
            *
            * @param {string} variableId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteVariable(variableId: string): Promise<{}>;
}

export class Projects {
        client: Client;
        constructor(client: Client);
        /**
            * List projects
            *
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProjectList>}
            */
        list(queries?: string[], search?: string): Promise<Models.ProjectList>;
        /**
            * Create project
            *
            *
            * @param {string} projectId
            * @param {string} name
            * @param {string} teamId
            * @param {Region} region
            * @param {string} description
            * @param {string} logo
            * @param {string} url
            * @param {string} legalName
            * @param {string} legalCountry
            * @param {string} legalState
            * @param {string} legalCity
            * @param {string} legalAddress
            * @param {string} legalTaxId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        create(projectId: string, name: string, teamId: string, region?: Region, description?: string, logo?: string, url?: string, legalName?: string, legalCountry?: string, legalState?: string, legalCity?: string, legalAddress?: string, legalTaxId?: string): Promise<Models.Project>;
        /**
            * Get project
            *
            *
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        get(projectId: string): Promise<Models.Project>;
        /**
            * Update project
            *
            *
            * @param {string} projectId
            * @param {string} name
            * @param {string} description
            * @param {string} logo
            * @param {string} url
            * @param {string} legalName
            * @param {string} legalCountry
            * @param {string} legalState
            * @param {string} legalCity
            * @param {string} legalAddress
            * @param {string} legalTaxId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        update(projectId: string, name: string, description?: string, logo?: string, url?: string, legalName?: string, legalCountry?: string, legalState?: string, legalCity?: string, legalAddress?: string, legalTaxId?: string): Promise<Models.Project>;
        /**
            * Delete project
            *
            *
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(projectId: string): Promise<{}>;
        /**
            * Update API status
            *
            *
            * @param {string} projectId
            * @param {Api} api
            * @param {boolean} status
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateApiStatus(projectId: string, api: Api, status: boolean): Promise<Models.Project>;
        /**
            * Update all API status
            *
            *
            * @param {string} projectId
            * @param {boolean} status
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateApiStatusAll(projectId: string, status: boolean): Promise<Models.Project>;
        /**
            * Update project authentication duration
            *
            *
            * @param {string} projectId
            * @param {number} duration
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateAuthDuration(projectId: string, duration: number): Promise<Models.Project>;
        /**
            * Update project users limit
            *
            *
            * @param {string} projectId
            * @param {number} limit
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateAuthLimit(projectId: string, limit: number): Promise<Models.Project>;
        /**
            * Update project user sessions limit
            *
            *
            * @param {string} projectId
            * @param {number} limit
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateAuthSessionsLimit(projectId: string, limit: number): Promise<Models.Project>;
        /**
            * Update the mock numbers for the project
            *
            *
            * @param {string} projectId
            * @param {object[]} numbers
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateMockNumbers(projectId: string, numbers: object[]): Promise<Models.Project>;
        /**
            * Update authentication password dictionary status. Use this endpoint to enable or disable the dicitonary check for user password
            *
            *
            * @param {string} projectId
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateAuthPasswordDictionary(projectId: string, enabled: boolean): Promise<Models.Project>;
        /**
            * Update authentication password history. Use this endpoint to set the number of password history to save and 0 to disable password history.
            *
            *
            * @param {string} projectId
            * @param {number} limit
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateAuthPasswordHistory(projectId: string, limit: number): Promise<Models.Project>;
        /**
            * Enable or disable checking user passwords for similarity with their personal data.
            *
            *
            * @param {string} projectId
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updatePersonalDataCheck(projectId: string, enabled: boolean): Promise<Models.Project>;
        /**
            * Update project sessions emails
            *
            *
            * @param {string} projectId
            * @param {boolean} alerts
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateSessionAlerts(projectId: string, alerts: boolean): Promise<Models.Project>;
        /**
            * Update project auth method status. Use this endpoint to enable or disable a given auth method for this project.
            *
            *
            * @param {string} projectId
            * @param {AuthMethod} method
            * @param {boolean} status
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateAuthStatus(projectId: string, method: AuthMethod, status: boolean): Promise<Models.Project>;
        /**
            * Create JWT
            *
            *
            * @param {string} projectId
            * @param {string[]} scopes
            * @param {number} duration
            * @throws {AppcondaException}
            * @returns {Promise<Models.Jwt>}
            */
        createJWT(projectId: string, scopes: string[], duration?: number): Promise<Models.Jwt>;
        /**
            * List keys
            *
            *
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<Models.KeyList>}
            */
        listKeys(projectId: string): Promise<Models.KeyList>;
        /**
            * Create key
            *
            *
            * @param {string} projectId
            * @param {string} name
            * @param {string[]} scopes
            * @param {string} expire
            * @throws {AppcondaException}
            * @returns {Promise<Models.Key>}
            */
        createKey(projectId: string, name: string, scopes: string[], expire?: string): Promise<Models.Key>;
        /**
            * Get key
            *
            *
            * @param {string} projectId
            * @param {string} keyId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Key>}
            */
        getKey(projectId: string, keyId: string): Promise<Models.Key>;
        /**
            * Update key
            *
            *
            * @param {string} projectId
            * @param {string} keyId
            * @param {string} name
            * @param {string[]} scopes
            * @param {string} expire
            * @throws {AppcondaException}
            * @returns {Promise<Models.Key>}
            */
        updateKey(projectId: string, keyId: string, name: string, scopes: string[], expire?: string): Promise<Models.Key>;
        /**
            * Delete key
            *
            *
            * @param {string} projectId
            * @param {string} keyId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteKey(projectId: string, keyId: string): Promise<{}>;
        /**
            * Update project OAuth2
            *
            *
            * @param {string} projectId
            * @param {OAuthProvider} provider
            * @param {string} appId
            * @param {string} secret
            * @param {boolean} enabled
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateOAuth2(projectId: string, provider: OAuthProvider, appId?: string, secret?: string, enabled?: boolean): Promise<Models.Project>;
        /**
            * List platforms
            *
            *
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<Models.PlatformList>}
            */
        listPlatforms(projectId: string): Promise<Models.PlatformList>;
        /**
            * Create platform
            *
            *
            * @param {string} projectId
            * @param {PlatformType} type
            * @param {string} name
            * @param {string} key
            * @param {string} store
            * @param {string} hostname
            * @throws {AppcondaException}
            * @returns {Promise<Models.Platform>}
            */
        createPlatform(projectId: string, type: PlatformType, name: string, key?: string, store?: string, hostname?: string): Promise<Models.Platform>;
        /**
            * Get platform
            *
            *
            * @param {string} projectId
            * @param {string} platformId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Platform>}
            */
        getPlatform(projectId: string, platformId: string): Promise<Models.Platform>;
        /**
            * Update platform
            *
            *
            * @param {string} projectId
            * @param {string} platformId
            * @param {string} name
            * @param {string} key
            * @param {string} store
            * @param {string} hostname
            * @throws {AppcondaException}
            * @returns {Promise<Models.Platform>}
            */
        updatePlatform(projectId: string, platformId: string, name: string, key?: string, store?: string, hostname?: string): Promise<Models.Platform>;
        /**
            * Delete platform
            *
            *
            * @param {string} projectId
            * @param {string} platformId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deletePlatform(projectId: string, platformId: string): Promise<{}>;
        /**
            * Update service status
            *
            *
            * @param {string} projectId
            * @param {ApiService} service
            * @param {boolean} status
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateServiceStatus(projectId: string, service: ApiService, status: boolean): Promise<Models.Project>;
        /**
            * Update all service status
            *
            *
            * @param {string} projectId
            * @param {boolean} status
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateServiceStatusAll(projectId: string, status: boolean): Promise<Models.Project>;
        /**
            * Update SMTP
            *
            *
            * @param {string} projectId
            * @param {boolean} enabled
            * @param {string} senderName
            * @param {string} senderEmail
            * @param {string} replyTo
            * @param {string} host
            * @param {number} port
            * @param {string} username
            * @param {string} password
            * @param {SMTPSecure} secure
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateSmtp(projectId: string, enabled: boolean, senderName?: string, senderEmail?: string, replyTo?: string, host?: string, port?: number, username?: string, password?: string, secure?: SMTPSecure): Promise<Models.Project>;
        /**
            * Create SMTP test
            *
            *
            * @param {string} projectId
            * @param {string[]} emails
            * @param {string} senderName
            * @param {string} senderEmail
            * @param {string} host
            * @param {string} replyTo
            * @param {number} port
            * @param {string} username
            * @param {string} password
            * @param {SMTPSecure} secure
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        createSmtpTest(projectId: string, emails: string[], senderName: string, senderEmail: string, host: string, replyTo?: string, port?: number, username?: string, password?: string, secure?: SMTPSecure): Promise<{}>;
        /**
            * Update project team
            *
            *
            * @param {string} projectId
            * @param {string} teamId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateTeam(projectId: string, teamId: string): Promise<Models.Project>;
        /**
            * Get custom email template
            *
            *
            * @param {string} projectId
            * @param {EmailTemplateType} type
            * @param {EmailTemplateLocale} locale
            * @throws {AppcondaException}
            * @returns {Promise<Models.EmailTemplate>}
            */
        getEmailTemplate(projectId: string, type: EmailTemplateType, locale: EmailTemplateLocale): Promise<Models.EmailTemplate>;
        /**
            * Update custom email templates
            *
            *
            * @param {string} projectId
            * @param {EmailTemplateType} type
            * @param {EmailTemplateLocale} locale
            * @param {string} subject
            * @param {string} message
            * @param {string} senderName
            * @param {string} senderEmail
            * @param {string} replyTo
            * @throws {AppcondaException}
            * @returns {Promise<Models.Project>}
            */
        updateEmailTemplate(projectId: string, type: EmailTemplateType, locale: EmailTemplateLocale, subject: string, message: string, senderName?: string, senderEmail?: string, replyTo?: string): Promise<Models.Project>;
        /**
            * Reset custom email template
            *
            *
            * @param {string} projectId
            * @param {EmailTemplateType} type
            * @param {EmailTemplateLocale} locale
            * @throws {AppcondaException}
            * @returns {Promise<Models.EmailTemplate>}
            */
        deleteEmailTemplate(projectId: string, type: EmailTemplateType, locale: EmailTemplateLocale): Promise<Models.EmailTemplate>;
        /**
            * Get custom SMS template
            *
            *
            * @param {string} projectId
            * @param {SmsTemplateType} type
            * @param {SmsTemplateLocale} locale
            * @throws {AppcondaException}
            * @returns {Promise<Models.SmsTemplate>}
            */
        getSmsTemplate(projectId: string, type: SmsTemplateType, locale: SmsTemplateLocale): Promise<Models.SmsTemplate>;
        /**
            * Update custom SMS template
            *
            *
            * @param {string} projectId
            * @param {SmsTemplateType} type
            * @param {SmsTemplateLocale} locale
            * @param {string} message
            * @throws {AppcondaException}
            * @returns {Promise<Models.SmsTemplate>}
            */
        updateSmsTemplate(projectId: string, type: SmsTemplateType, locale: SmsTemplateLocale, message: string): Promise<Models.SmsTemplate>;
        /**
            * Reset custom SMS template
            *
            *
            * @param {string} projectId
            * @param {SmsTemplateType} type
            * @param {SmsTemplateLocale} locale
            * @throws {AppcondaException}
            * @returns {Promise<Models.SmsTemplate>}
            */
        deleteSmsTemplate(projectId: string, type: SmsTemplateType, locale: SmsTemplateLocale): Promise<Models.SmsTemplate>;
        /**
            * List webhooks
            *
            *
            * @param {string} projectId
            * @throws {AppcondaException}
            * @returns {Promise<Models.WebhookList>}
            */
        listWebhooks(projectId: string): Promise<Models.WebhookList>;
        /**
            * Create webhook
            *
            *
            * @param {string} projectId
            * @param {string} name
            * @param {string[]} events
            * @param {string} url
            * @param {boolean} security
            * @param {boolean} enabled
            * @param {string} httpUser
            * @param {string} httpPass
            * @throws {AppcondaException}
            * @returns {Promise<Models.Webhook>}
            */
        createWebhook(projectId: string, name: string, events: string[], url: string, security: boolean, enabled?: boolean, httpUser?: string, httpPass?: string): Promise<Models.Webhook>;
        /**
            * Get webhook
            *
            *
            * @param {string} projectId
            * @param {string} webhookId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Webhook>}
            */
        getWebhook(projectId: string, webhookId: string): Promise<Models.Webhook>;
        /**
            * Update webhook
            *
            *
            * @param {string} projectId
            * @param {string} webhookId
            * @param {string} name
            * @param {string[]} events
            * @param {string} url
            * @param {boolean} security
            * @param {boolean} enabled
            * @param {string} httpUser
            * @param {string} httpPass
            * @throws {AppcondaException}
            * @returns {Promise<Models.Webhook>}
            */
        updateWebhook(projectId: string, webhookId: string, name: string, events: string[], url: string, security: boolean, enabled?: boolean, httpUser?: string, httpPass?: string): Promise<Models.Webhook>;
        /**
            * Delete webhook
            *
            *
            * @param {string} projectId
            * @param {string} webhookId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteWebhook(projectId: string, webhookId: string): Promise<{}>;
        /**
            * Update webhook signature key
            *
            *
            * @param {string} projectId
            * @param {string} webhookId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Webhook>}
            */
        updateWebhookSignature(projectId: string, webhookId: string): Promise<Models.Webhook>;
}

export class Proxy {
        client: Client;
        constructor(client: Client);
        /**
            * List Rules
            *
            * Get a list of all the proxy rules. You can use the query params to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProxyRuleList>}
            */
        listRules(queries?: string[], search?: string): Promise<Models.ProxyRuleList>;
        /**
            * Create Rule
            *
            * Create a new proxy rule.
            *
            * @param {string} domain
            * @param {ResourceType} resourceType
            * @param {string} resourceId
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProxyRule>}
            */
        createRule(domain: string, resourceType: ResourceType, resourceId?: string): Promise<Models.ProxyRule>;
        /**
            * Get Rule
            *
            * Get a proxy rule by its unique ID.
            *
            * @param {string} ruleId
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProxyRule>}
            */
        getRule(ruleId: string): Promise<Models.ProxyRule>;
        /**
            * Delete Rule
            *
            * Delete a proxy rule by its unique ID.
            *
            * @param {string} ruleId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteRule(ruleId: string): Promise<{}>;
        /**
            * Update Rule Verification Status
            *
            *
            * @param {string} ruleId
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProxyRule>}
            */
        updateRuleVerification(ruleId: string): Promise<Models.ProxyRule>;
}

export class Storage {
        client: Client;
        constructor(client: Client);
        /**
            * List buckets
            *
            * Get a list of all the storage buckets. You can use the query params to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.BucketList>}
            */
        listBuckets(queries?: string[], search?: string): Promise<Models.BucketList>;
        /**
            * Create bucket
            *
            * Create a new storage bucket.
            *
            * @param {string} bucketId
            * @param {string} name
            * @param {string[]} permissions
            * @param {boolean} fileSecurity
            * @param {boolean} enabled
            * @param {number} maximumFileSize
            * @param {string[]} allowedFileExtensions
            * @param {Compression} compression
            * @param {boolean} encryption
            * @param {boolean} antivirus
            * @throws {AppcondaException}
            * @returns {Promise<Models.Bucket>}
            */
        createBucket(bucketId: string, name: string, permissions?: string[], fileSecurity?: boolean, enabled?: boolean, maximumFileSize?: number, allowedFileExtensions?: string[], compression?: Compression, encryption?: boolean, antivirus?: boolean): Promise<Models.Bucket>;
        /**
            * Get bucket
            *
            * Get a storage bucket by its unique ID. This endpoint response returns a JSON object with the storage bucket metadata.
            *
            * @param {string} bucketId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Bucket>}
            */
        getBucket(bucketId: string): Promise<Models.Bucket>;
        /**
            * Update bucket
            *
            * Update a storage bucket by its unique ID.
            *
            * @param {string} bucketId
            * @param {string} name
            * @param {string[]} permissions
            * @param {boolean} fileSecurity
            * @param {boolean} enabled
            * @param {number} maximumFileSize
            * @param {string[]} allowedFileExtensions
            * @param {Compression} compression
            * @param {boolean} encryption
            * @param {boolean} antivirus
            * @throws {AppcondaException}
            * @returns {Promise<Models.Bucket>}
            */
        updateBucket(bucketId: string, name: string, permissions?: string[], fileSecurity?: boolean, enabled?: boolean, maximumFileSize?: number, allowedFileExtensions?: string[], compression?: Compression, encryption?: boolean, antivirus?: boolean): Promise<Models.Bucket>;
        /**
            * Delete bucket
            *
            * Delete a storage bucket by its unique ID.
            *
            * @param {string} bucketId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteBucket(bucketId: string): Promise<{}>;
        /**
            * List files
            *
            * Get a list of all the user files. You can use the query params to filter your results.
            *
            * @param {string} bucketId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.FileList>}
            */
        listFiles(bucketId: string, queries?: string[], search?: string): Promise<Models.FileList>;
        /**
            * Create file
            *
            * Create a new file. Before using this route, you should create a new bucket resource using either a [server integration](https://appconda.io/docs/server/storage#storageCreateBucket) API or directly from your Appconda console.

Larger files should be uploaded using multiple requests with the [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range) header to send a partial request with a maximum supported chunk of `5MB`. The `content-range` header values should always be in bytes.

When the first request is sent, the server will return the **File** object, and the subsequent part request must include the file&#039;s **id** in `x-appconda-id` header to allow the server to know that the partial upload is for the existing file and not for a new one.

If you&#039;re creating a new file using one of the Appconda SDKs, all the chunking logic will be managed by the SDK internally.

            *
            * @param {string} bucketId
            * @param {string} fileId
            * @param {File} file
            * @param {string[]} permissions
            * @throws {AppcondaException}
            * @returns {Promise<Models.File>}
            */
        createFile(bucketId: string, fileId: string, file: File, permissions?: string[], onProgress?: (progress: UploadProgress) => void): Promise<Models.File>;
        /**
            * Get file
            *
            * Get a file by its unique ID. This endpoint response returns a JSON object with the file metadata.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppcondaException}
            * @returns {Promise<Models.File>}
            */
        getFile(bucketId: string, fileId: string): Promise<Models.File>;
        /**
            * Update file
            *
            * Update a file by its unique ID. Only users with write permissions have access to update this resource.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @param {string} name
            * @param {string[]} permissions
            * @throws {AppcondaException}
            * @returns {Promise<Models.File>}
            */
        updateFile(bucketId: string, fileId: string, name?: string, permissions?: string[]): Promise<Models.File>;
        /**
            * Delete File
            *
            * Delete a file by its unique ID. Only users with write permissions have access to delete this resource.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteFile(bucketId: string, fileId: string): Promise<{}>;
        /**
            * Get file for download
            *
            * Get a file content by its unique ID. The endpoint response return with a &#039;Content-Disposition: attachment&#039; header that tells the browser to start downloading the file to user downloads directory.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppcondaException}
            * @returns {string}
            */
        getFileDownload(bucketId: string, fileId: string): string;
        /**
            * Get file preview
            *
            * Get a file preview image. Currently, this method supports preview for image files (jpg, png, and gif), other supported formats, like pdf, docs, slides, and spreadsheets, will return the file icon image. You can also pass query string arguments for cutting and resizing your preview image. Preview is supported only for image files smaller than 10MB.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @param {number} width
            * @param {number} height
            * @param {ImageGravity} gravity
            * @param {number} quality
            * @param {number} borderWidth
            * @param {string} borderColor
            * @param {number} borderRadius
            * @param {number} opacity
            * @param {number} rotation
            * @param {string} background
            * @param {ImageFormat} output
            * @throws {AppcondaException}
            * @returns {string}
            */
        getFilePreview(bucketId: string, fileId: string, width?: number, height?: number, gravity?: ImageGravity, quality?: number, borderWidth?: number, borderColor?: string, borderRadius?: number, opacity?: number, rotation?: number, background?: string, output?: ImageFormat): string;
        /**
            * Get file for view
            *
            * Get a file content by its unique ID. This endpoint is similar to the download method but returns with no  &#039;Content-Disposition: attachment&#039; header.
            *
            * @param {string} bucketId
            * @param {string} fileId
            * @throws {AppcondaException}
            * @returns {string}
            */
        getFileView(bucketId: string, fileId: string): string;
        /**
            * Get storage usage stats
            *
            *
            * @param {StorageUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageStorage>}
            */
        getUsage(range?: StorageUsageRange): Promise<Models.UsageStorage>;
        /**
            * Get bucket usage stats
            *
            *
            * @param {string} bucketId
            * @param {StorageUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageBuckets>}
            */
        getBucketUsage(bucketId: string, range?: StorageUsageRange): Promise<Models.UsageBuckets>;
}

export class Teams {
        client: Client;
        constructor(client: Client);
        /**
            * List teams
            *
            * Get a list of all the teams in which the current user is a member. You can use the parameters to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.TeamList<Preferences>>}
            */
        list<Preferences extends Models.Preferences>(queries?: string[], search?: string): Promise<Models.TeamList<Preferences>>;
        /**
            * Create team
            *
            * Create a new team. The user who creates the team will automatically be assigned as the owner of the team. Only the users with the owner role can invite new members, add new owners and delete or update the team.
            *
            * @param {string} teamId
            * @param {string} name
            * @param {string[]} roles
            * @throws {AppcondaException}
            * @returns {Promise<Models.Team<Preferences>>}
            */
        create<Preferences extends Models.Preferences>(teamId: string, name: string, roles?: string[]): Promise<Models.Team<Preferences>>;
        /**
            * Get team
            *
            * Get a team by its ID. All team members have read access for this resource.
            *
            * @param {string} teamId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Team<Preferences>>}
            */
        get<Preferences extends Models.Preferences>(teamId: string): Promise<Models.Team<Preferences>>;
        /**
            * Update name
            *
            * Update the team&#039;s name by its unique ID.
            *
            * @param {string} teamId
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.Team<Preferences>>}
            */
        updateName<Preferences extends Models.Preferences>(teamId: string, name: string): Promise<Models.Team<Preferences>>;
        /**
            * Delete team
            *
            * Delete a team using its ID. Only team members with the owner role can delete the team.
            *
            * @param {string} teamId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(teamId: string): Promise<{}>;
        /**
            * List team logs
            *
            * Get the team activity logs list by its unique ID.
            *
            * @param {string} teamId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listLogs(teamId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List team memberships
            *
            * Use this endpoint to list a team&#039;s members using the team&#039;s ID. All team members have read access to this endpoint.
            *
            * @param {string} teamId
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.MembershipList>}
            */
        listMemberships(teamId: string, queries?: string[], search?: string): Promise<Models.MembershipList>;
        /**
            * Create team membership
            *
            * Invite a new member to join your team. Provide an ID for existing users, or invite unregistered users using an email or phone number. If initiated from a Client SDK, Appconda will send an email or sms with a link to join the team to the invited user, and an account will be created for them if one doesn&#039;t exist. If initiated from a Server SDK, the new member will be added automatically to the team.

You only need to provide one of a user ID, email, or phone number. Appconda will prioritize accepting the user ID &gt; email &gt; phone number if you provide more than one of these parameters.

Use the `url` parameter to redirect the user from the invitation email to your app. After the user is redirected, use the [Update Team Membership Status](https://appconda.io/docs/references/cloud/client-web/teams#updateMembershipStatus) endpoint to allow the user to accept the invitation to the team.

Please note that to avoid a [Redirect Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md) Appconda will accept the only redirect URLs under the domains you have added as a platform on the Appconda Console.

            *
            * @param {string} teamId
            * @param {string[]} roles
            * @param {string} email
            * @param {string} userId
            * @param {string} phone
            * @param {string} url
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.Membership>}
            */
        createMembership(teamId: string, roles: string[], email?: string, userId?: string, phone?: string, url?: string, name?: string): Promise<Models.Membership>;
        /**
            * Get team membership
            *
            * Get a team member by the membership unique id. All team members have read access for this resource.
            *
            * @param {string} teamId
            * @param {string} membershipId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Membership>}
            */
        getMembership(teamId: string, membershipId: string): Promise<Models.Membership>;
        /**
            * Update membership
            *
            * Modify the roles of a team member. Only team members with the owner role have access to this endpoint. Learn more about [roles and permissions](https://appconda.io/docs/permissions).

            *
            * @param {string} teamId
            * @param {string} membershipId
            * @param {string[]} roles
            * @throws {AppcondaException}
            * @returns {Promise<Models.Membership>}
            */
        updateMembership(teamId: string, membershipId: string, roles: string[]): Promise<Models.Membership>;
        /**
            * Delete team membership
            *
            * This endpoint allows a user to leave a team or for a team owner to delete the membership of any other team member. You can also use this endpoint to delete a user membership even if it is not accepted.
            *
            * @param {string} teamId
            * @param {string} membershipId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteMembership(teamId: string, membershipId: string): Promise<{}>;
        /**
            * Update team membership status
            *
            * Use this endpoint to allow a user to accept an invitation to join a team after being redirected back to your app from the invitation email received by the user.

If the request is successful, a session for the user is automatically created.

            *
            * @param {string} teamId
            * @param {string} membershipId
            * @param {string} userId
            * @param {string} secret
            * @throws {AppcondaException}
            * @returns {Promise<Models.Membership>}
            */
        updateMembershipStatus(teamId: string, membershipId: string, userId: string, secret: string): Promise<Models.Membership>;
        /**
            * Get team preferences
            *
            * Get the team&#039;s shared preferences by its unique ID. If a preference doesn&#039;t need to be shared by all team members, prefer storing them in [user preferences](https://appconda.io/docs/references/cloud/client-web/account#getPrefs).
            *
            * @param {string} teamId
            * @throws {AppcondaException}
            * @returns {Promise<Preferences>}
            */
        getPrefs<Preferences extends Models.Preferences>(teamId: string): Promise<Preferences>;
        /**
            * Update preferences
            *
            * Update the team&#039;s preferences by its unique ID. The object you pass is stored as is and replaces any previous value. The maximum allowed prefs size is 64kB and throws an error if exceeded.
            *
            * @param {string} teamId
            * @param {object} prefs
            * @throws {AppcondaException}
            * @returns {Promise<Preferences>}
            */
        updatePrefs<Preferences extends Models.Preferences>(teamId: string, prefs: object): Promise<Preferences>;
}

export class Users {
        client: Client;
        constructor(client: Client);
        /**
            * List users
            *
            * Get a list of all the project&#039;s users. You can use the query params to filter your results.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.UserList<Preferences>>}
            */
        list<Preferences extends Models.Preferences>(queries?: string[], search?: string): Promise<Models.UserList<Preferences>>;
        /**
            * Create user
            *
            * Create a new user.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} phone
            * @param {string} password
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        create<Preferences extends Models.Preferences>(userId: string, email?: string, phone?: string, password?: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Create user with Argon2 password
            *
            * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createArgon2User<Preferences extends Models.Preferences>(userId: string, email: string, password: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Create user with bcrypt password
            *
            * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createBcryptUser<Preferences extends Models.Preferences>(userId: string, email: string, password: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * List Identities
            *
            * Get identities for all users.
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.IdentityList>}
            */
        listIdentities(queries?: string[], search?: string): Promise<Models.IdentityList>;
        /**
            * Delete identity
            *
            * Delete an identity by its unique ID.
            *
            * @param {string} identityId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteIdentity(identityId: string): Promise<{}>;
        /**
            * Create user with MD5 password
            *
            * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createMD5User<Preferences extends Models.Preferences>(userId: string, email: string, password: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Create user with PHPass password
            *
            * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createPHPassUser<Preferences extends Models.Preferences>(userId: string, email: string, password: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Create user with Scrypt password
            *
            * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} passwordSalt
            * @param {number} passwordCpu
            * @param {number} passwordMemory
            * @param {number} passwordParallel
            * @param {number} passwordLength
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createScryptUser<Preferences extends Models.Preferences>(userId: string, email: string, password: string, passwordSalt: string, passwordCpu: number, passwordMemory: number, passwordParallel: number, passwordLength: number, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Create user with Scrypt modified password
            *
            * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {string} passwordSalt
            * @param {string} passwordSaltSeparator
            * @param {string} passwordSignerKey
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createScryptModifiedUser<Preferences extends Models.Preferences>(userId: string, email: string, password: string, passwordSalt: string, passwordSaltSeparator: string, passwordSignerKey: string, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Create user with SHA password
            *
            * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appconda.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
            *
            * @param {string} userId
            * @param {string} email
            * @param {string} password
            * @param {PasswordHash} passwordVersion
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        createSHAUser<Preferences extends Models.Preferences>(userId: string, email: string, password: string, passwordVersion?: PasswordHash, name?: string): Promise<Models.User<Preferences>>;
        /**
            * Get users usage stats
            *
            *
            * @param {UserUsageRange} range
            * @throws {AppcondaException}
            * @returns {Promise<Models.UsageUsers>}
            */
        getUsage(range?: UserUsageRange): Promise<Models.UsageUsers>;
        /**
            * Get user
            *
            * Get a user by its unique ID.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        get<Preferences extends Models.Preferences>(userId: string): Promise<Models.User<Preferences>>;
        /**
            * Delete user
            *
            * Delete a user by its unique ID, thereby releasing it&#039;s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appconda.io/docs/server/users#usersUpdateStatus) endpoint instead.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        delete(userId: string): Promise<{}>;
        /**
            * Update email
            *
            * Update the user email by its unique ID.
            *
            * @param {string} userId
            * @param {string} email
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateEmail<Preferences extends Models.Preferences>(userId: string, email: string): Promise<Models.User<Preferences>>;
        /**
            * Create user JWT
            *
            * Use this endpoint to create a JSON Web Token for user by its unique ID. You can use the resulting JWT to authenticate on behalf of the user. The JWT secret will become invalid if the session it uses gets deleted.
            *
            * @param {string} userId
            * @param {string} sessionId
            * @param {number} duration
            * @throws {AppcondaException}
            * @returns {Promise<Models.Jwt>}
            */
        createJWT(userId: string, sessionId?: string, duration?: number): Promise<Models.Jwt>;
        /**
            * Update user labels
            *
            * Update the user labels by its unique ID.

Labels can be used to grant access to resources. While teams are a way for user&#039;s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appconda.io/docs/permissions) for more info.
            *
            * @param {string} userId
            * @param {string[]} labels
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateLabels<Preferences extends Models.Preferences>(userId: string, labels: string[]): Promise<Models.User<Preferences>>;
        /**
            * List user logs
            *
            * Get the user activity logs list by its unique ID.
            *
            * @param {string} userId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.LogList>}
            */
        listLogs(userId: string, queries?: string[]): Promise<Models.LogList>;
        /**
            * List user memberships
            *
            * Get the user membership list by its unique ID.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.MembershipList>}
            */
        listMemberships(userId: string): Promise<Models.MembershipList>;
        /**
            * Update MFA
            *
            * Enable or disable MFA on a user account.
            *
            * @param {string} userId
            * @param {boolean} mfa
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateMfa<Preferences extends Models.Preferences>(userId: string, mfa: boolean): Promise<Models.User<Preferences>>;
        /**
            * Delete Authenticator
            *
            * Delete an authenticator app.
            *
            * @param {string} userId
            * @param {AuthenticatorType} type
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        deleteMfaAuthenticator<Preferences extends Models.Preferences>(userId: string, type: AuthenticatorType): Promise<Models.User<Preferences>>;
        /**
            * List Factors
            *
            * List the factors available on the account to be used as a MFA challange.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaFactors>}
            */
        listMfaFactors(userId: string): Promise<Models.MfaFactors>;
        /**
            * Get MFA Recovery Codes
            *
            * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaRecoveryCodes>}
            */
        getMfaRecoveryCodes(userId: string): Promise<Models.MfaRecoveryCodes>;
        /**
            * Regenerate MFA Recovery Codes
            *
            * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaRecoveryCodes>}
            */
        updateMfaRecoveryCodes(userId: string): Promise<Models.MfaRecoveryCodes>;
        /**
            * Create MFA Recovery Codes
            *
            * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.MfaRecoveryCodes>}
            */
        createMfaRecoveryCodes(userId: string): Promise<Models.MfaRecoveryCodes>;
        /**
            * Update name
            *
            * Update the user name by its unique ID.
            *
            * @param {string} userId
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateName<Preferences extends Models.Preferences>(userId: string, name: string): Promise<Models.User<Preferences>>;
        /**
            * Update password
            *
            * Update the user password by its unique ID.
            *
            * @param {string} userId
            * @param {string} password
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updatePassword<Preferences extends Models.Preferences>(userId: string, password: string): Promise<Models.User<Preferences>>;
        /**
            * Update phone
            *
            * Update the user phone by its unique ID.
            *
            * @param {string} userId
            * @param {string} number
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updatePhone<Preferences extends Models.Preferences>(userId: string, number: string): Promise<Models.User<Preferences>>;
        /**
            * Get user preferences
            *
            * Get the user preferences by its unique ID.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Preferences>}
            */
        getPrefs<Preferences extends Models.Preferences>(userId: string): Promise<Preferences>;
        /**
            * Update user preferences
            *
            * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
            *
            * @param {string} userId
            * @param {object} prefs
            * @throws {AppcondaException}
            * @returns {Promise<Preferences>}
            */
        updatePrefs<Preferences extends Models.Preferences>(userId: string, prefs: object): Promise<Preferences>;
        /**
            * List user sessions
            *
            * Get the user sessions list by its unique ID.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.SessionList>}
            */
        listSessions(userId: string): Promise<Models.SessionList>;
        /**
            * Create session
            *
            * Creates a session for a user. Returns an immediately usable session object.

If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appconda.io/docs/server/users#createToken) endpoint.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Session>}
            */
        createSession(userId: string): Promise<Models.Session>;
        /**
            * Delete user sessions
            *
            * Delete all user&#039;s sessions by using the user&#039;s unique ID.
            *
            * @param {string} userId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteSessions(userId: string): Promise<{}>;
        /**
            * Delete user session
            *
            * Delete a user sessions by its unique ID.
            *
            * @param {string} userId
            * @param {string} sessionId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteSession(userId: string, sessionId: string): Promise<{}>;
        /**
            * Update user status
            *
            * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user&#039;s ID reserved.
            *
            * @param {string} userId
            * @param {boolean} status
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateStatus<Preferences extends Models.Preferences>(userId: string, status: boolean): Promise<Models.User<Preferences>>;
        /**
            * List User Targets
            *
            * List the messaging targets that are associated with a user.
            *
            * @param {string} userId
            * @param {string[]} queries
            * @throws {AppcondaException}
            * @returns {Promise<Models.TargetList>}
            */
        listTargets(userId: string, queries?: string[]): Promise<Models.TargetList>;
        /**
            * Create User Target
            *
            * Create a messaging target.
            *
            * @param {string} userId
            * @param {string} targetId
            * @param {MessagingProviderType} providerType
            * @param {string} identifier
            * @param {string} providerId
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.Target>}
            */
        createTarget(userId: string, targetId: string, providerType: MessagingProviderType, identifier: string, providerId?: string, name?: string): Promise<Models.Target>;
        /**
            * Get User Target
            *
            * Get a user&#039;s push notification target by ID.
            *
            * @param {string} userId
            * @param {string} targetId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Target>}
            */
        getTarget(userId: string, targetId: string): Promise<Models.Target>;
        /**
            * Update User target
            *
            * Update a messaging target.
            *
            * @param {string} userId
            * @param {string} targetId
            * @param {string} identifier
            * @param {string} providerId
            * @param {string} name
            * @throws {AppcondaException}
            * @returns {Promise<Models.Target>}
            */
        updateTarget(userId: string, targetId: string, identifier?: string, providerId?: string, name?: string): Promise<Models.Target>;
        /**
            * Delete user target
            *
            * Delete a messaging target.
            *
            * @param {string} userId
            * @param {string} targetId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteTarget(userId: string, targetId: string): Promise<{}>;
        /**
            * Create token
            *
            * Returns a token with a secret key for creating a session. Use the user ID and secret and submit a request to the [PUT /account/sessions/token](https://appconda.io/docs/references/cloud/client-web/account#createSession) endpoint to complete the login process.

            *
            * @param {string} userId
            * @param {number} length
            * @param {number} expire
            * @throws {AppcondaException}
            * @returns {Promise<Models.Token>}
            */
        createToken(userId: string, length?: number, expire?: number): Promise<Models.Token>;
        /**
            * Update email verification
            *
            * Update the user email verification status by its unique ID.
            *
            * @param {string} userId
            * @param {boolean} emailVerification
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updateEmailVerification<Preferences extends Models.Preferences>(userId: string, emailVerification: boolean): Promise<Models.User<Preferences>>;
        /**
            * Update phone verification
            *
            * Update the user phone verification status by its unique ID.
            *
            * @param {string} userId
            * @param {boolean} phoneVerification
            * @throws {AppcondaException}
            * @returns {Promise<Models.User<Preferences>>}
            */
        updatePhoneVerification<Preferences extends Models.Preferences>(userId: string, phoneVerification: boolean): Promise<Models.User<Preferences>>;
}

export class Vcs {
        client: Client;
        constructor(client: Client);
        /**
            * List Repositories
            *
            *
            * @param {string} installationId
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProviderRepositoryList>}
            */
        listRepositories(installationId: string, search?: string): Promise<Models.ProviderRepositoryList>;
        /**
            * Create repository
            *
            *
            * @param {string} installationId
            * @param {string} name
            * @param {boolean} xprivate
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProviderRepository>}
            */
        createRepository(installationId: string, name: string, xprivate: boolean): Promise<Models.ProviderRepository>;
        /**
            * Get repository
            *
            *
            * @param {string} installationId
            * @param {string} providerRepositoryId
            * @throws {AppcondaException}
            * @returns {Promise<Models.ProviderRepository>}
            */
        getRepository(installationId: string, providerRepositoryId: string): Promise<Models.ProviderRepository>;
        /**
            * List Repository Branches
            *
            *
            * @param {string} installationId
            * @param {string} providerRepositoryId
            * @throws {AppcondaException}
            * @returns {Promise<Models.BranchList>}
            */
        listRepositoryBranches(installationId: string, providerRepositoryId: string): Promise<Models.BranchList>;
        /**
            * Get files and directories of a VCS repository
            *
            *
            * @param {string} installationId
            * @param {string} providerRepositoryId
            * @param {string} providerRootDirectory
            * @throws {AppcondaException}
            * @returns {Promise<Models.VcsContentList>}
            */
        getRepositoryContents(installationId: string, providerRepositoryId: string, providerRootDirectory?: string): Promise<Models.VcsContentList>;
        /**
            * Detect runtime settings from source code
            *
            *
            * @param {string} installationId
            * @param {string} providerRepositoryId
            * @param {string} providerRootDirectory
            * @throws {AppcondaException}
            * @returns {Promise<Models.Detection>}
            */
        createRepositoryDetection(installationId: string, providerRepositoryId: string, providerRootDirectory?: string): Promise<Models.Detection>;
        /**
            * Authorize external deployment
            *
            *
            * @param {string} installationId
            * @param {string} repositoryId
            * @param {string} providerPullRequestId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        updateExternalDeployments(installationId: string, repositoryId: string, providerPullRequestId: string): Promise<{}>;
        /**
            * List installations
            *
            *
            * @param {string[]} queries
            * @param {string} search
            * @throws {AppcondaException}
            * @returns {Promise<Models.InstallationList>}
            */
        listInstallations(queries?: string[], search?: string): Promise<Models.InstallationList>;
        /**
            * Get installation
            *
            *
            * @param {string} installationId
            * @throws {AppcondaException}
            * @returns {Promise<Models.Installation>}
            */
        getInstallation(installationId: string): Promise<Models.Installation>;
        /**
            * Delete Installation
            *
            *
            * @param {string} installationId
            * @throws {AppcondaException}
            * @returns {Promise<{}>}
            */
        deleteInstallation(installationId: string): Promise<{}>;
}

type QueryTypesSingle = string | number | boolean;
export type QueryTypesList = string[] | number[] | boolean[] | Query[];
export type QueryTypes = QueryTypesSingle | QueryTypesList;
type AttributesTypes = string | string[];
/**
    * Helper class to generate query strings.
    */
export class Query {
        method: string;
        attribute: AttributesTypes | undefined;
        values: QueryTypesList | undefined;
        /**
            * Constructor for Query class.
            *
            * @param {string} method
            * @param {AttributesTypes} attribute
            * @param {QueryTypes} values
            */
        constructor(method: string, attribute?: AttributesTypes, values?: QueryTypes);
        /**
            * Convert the query object to a JSON string.
            *
            * @returns {string}
            */
        toString(): string;
        /**
            * Filter resources where attribute is equal to value.
            *
            * @param {string} attribute
            * @param {QueryTypes} value
            * @returns {string}
            */
        static equal: (attribute: string, value: QueryTypes) => string;
        /**
            * Filter resources where attribute is not equal to value.
            *
            * @param {string} attribute
            * @param {QueryTypes} value
            * @returns {string}
            */
        static notEqual: (attribute: string, value: QueryTypes) => string;
        /**
            * Filter resources where attribute is less than value.
            *
            * @param {string} attribute
            * @param {QueryTypes} value
            * @returns {string}
            */
        static lessThan: (attribute: string, value: QueryTypes) => string;
        /**
            * Filter resources where attribute is less than or equal to value.
            *
            * @param {string} attribute
            * @param {QueryTypes} value
            * @returns {string}
            */
        static lessThanEqual: (attribute: string, value: QueryTypes) => string;
        /**
            * Filter resources where attribute is greater than value.
            *
            * @param {string} attribute
            * @param {QueryTypes} value
            * @returns {string}
            */
        static greaterThan: (attribute: string, value: QueryTypes) => string;
        /**
            * Filter resources where attribute is greater than or equal to value.
            *
            * @param {string} attribute
            * @param {QueryTypes} value
            * @returns {string}
            */
        static greaterThanEqual: (attribute: string, value: QueryTypes) => string;
        /**
            * Filter resources where attribute is null.
            *
            * @param {string} attribute
            * @returns {string}
            */
        static isNull: (attribute: string) => string;
        /**
            * Filter resources where attribute is not null.
            *
            * @param {string} attribute
            * @returns {string}
            */
        static isNotNull: (attribute: string) => string;
        /**
            * Filter resources where attribute is between start and end (inclusive).
            *
            * @param {string} attribute
            * @param {string | number} start
            * @param {string | number} end
            * @returns {string}
            */
        static between: (attribute: string, start: string | number, end: string | number) => string;
        /**
            * Filter resources where attribute starts with value.
            *
            * @param {string} attribute
            * @param {string} value
            * @returns {string}
            */
        static startsWith: (attribute: string, value: string) => string;
        /**
            * Filter resources where attribute ends with value.
            *
            * @param {string} attribute
            * @param {string} value
            * @returns {string}
            */
        static endsWith: (attribute: string, value: string) => string;
        /**
            * Specify which attributes should be returned by the API call.
            *
            * @param {string[]} attributes
            * @returns {string}
            */
        static select: (attributes: string[]) => string;
        /**
            * Filter resources by searching attribute for value.
            * A fulltext index on attribute is required for this query to work.
            *
            * @param {string} attribute
            * @param {string} value
            * @returns {string}
            */
        static search: (attribute: string, value: string) => string;
        /**
            * Sort results by attribute descending.
            *
            * @param {string} attribute
            * @returns {string}
            */
        static orderDesc: (attribute: string) => string;
        /**
            * Sort results by attribute ascending.
            *
            * @param {string} attribute
            * @returns {string}
            */
        static orderAsc: (attribute: string) => string;
        /**
            * Return results after documentId.
            *
            * @param {string} documentId
            * @returns {string}
            */
        static cursorAfter: (documentId: string) => string;
        /**
            * Return results before documentId.
            *
            * @param {string} documentId
            * @returns {string}
            */
        static cursorBefore: (documentId: string) => string;
        /**
            * Return only limit results.
            *
            * @param {number} limit
            * @returns {string}
            */
        static limit: (limit: number) => string;
        /**
            * Filter resources by skipping the first offset results.
            *
            * @param {number} offset
            * @returns {string}
            */
        static offset: (offset: number) => string;
        /**
            * Filter resources where attribute contains the specified value.
            *
            * @param {string} attribute
            * @param {string | string[]} value
            * @returns {string}
            */
        static contains: (attribute: string, value: string | string[]) => string;
        /**
            * Combine multiple queries using logical OR operator.
            *
            * @param {string[]} queries
            * @returns {string}
            */
        static or: (queries: string[]) => string;
        /**
            * Combine multiple queries using logical AND operator.
            *
            * @param {string[]} queries
            * @returns {string}
            */
        static and: (queries: string[]) => string;
}
export {};

/**
    * Helper class to generate permission strings for resources.
    */
export class Permission {
        /**
            * Generate read permission string for the provided role.
            *
            * @param {string} role
            * @returns {string}
            */
        static read: (role: string) => string;
        /**
            * Generate write permission string for the provided role.
            *
            * This is an alias of update, delete, and possibly create.
            * Don't use write in combination with update, delete, or create.
            *
            * @param {string} role
            * @returns {string}
            */
        static write: (role: string) => string;
        /**
            * Generate create permission string for the provided role.
            *
            * @param {string} role
            * @returns {string}
            */
        static create: (role: string) => string;
        /**
            * Generate update permission string for the provided role.
            *
            * @param {string} role
            * @returns {string}
            */
        static update: (role: string) => string;
        /**
            * Generate delete permission string for the provided role.
            *
            * @param {string} role
            * @returns {string}
            */
        static delete: (role: string) => string;
}

/**
    * Helper class to generate role strings for `Permission`.
    */
export class Role {
        /**
            * Grants access to anyone.
            *
            * This includes authenticated and unauthenticated users.
            *
            * @returns {string}
            */
        static any(): string;
        /**
            * Grants access to a specific user by user ID.
            *
            * You can optionally pass verified or unverified for
            * `status` to target specific types of users.
            *
            * @param {string} id
            * @param {string} status
            * @returns {string}
            */
        static user(id: string, status?: string): string;
        /**
            * Grants access to any authenticated or anonymous user.
            *
            * You can optionally pass verified or unverified for
            * `status` to target specific types of users.
            *
            * @param {string} status
            * @returns {string}
            */
        static users(status?: string): string;
        /**
            * Grants access to any guest user without a session.
            *
            * Authenticated users don't have access to this role.
            *
            * @returns {string}
            */
        static guests(): string;
        /**
            * Grants access to a team by team ID.
            *
            * You can optionally pass a role for `role` to target
            * team members with the specified role.
            *
            * @param {string} id
            * @param {string} role
            * @returns {string}
            */
        static team(id: string, role?: string): string;
        /**
            * Grants access to a specific member of a team.
            *
            * When the member is removed from the team, they will
            * no longer have access.
            *
            * @param {string} id
            * @returns {string}
            */
        static member(id: string): string;
        /**
            * Grants access to a user with the specified label.
            *
            * @param {string} name
            * @returns  {string}
            */
        static label(name: string): string;
}

/**
    * Helper class to generate ID strings for resources.
    */
export class ID {
        #private;
        /**
            * Uses the provided ID as the ID for the resource.
            *
            * @param {string} id
            * @returns {string}
            */
        static custom(id: string): string;
        /**
            * Have Appconda generate a unique ID for you.
            *
            * @param {number} padding. Default is 7.
            * @returns {string}
            */
        static unique(padding?: number): string;
}

export enum AuthenticatorType {
    Totp = "totp"
}

export enum AuthenticationFactor {
    Email = "email",
    Phone = "phone",
    Totp = "totp",
    Recoverycode = "recoverycode"
}

export enum OAuthProvider {
    Amazon = "amazon",
    Apple = "apple",
    Auth0 = "auth0",
    Authentik = "authentik",
    Autodesk = "autodesk",
    Bitbucket = "bitbucket",
    Bitly = "bitly",
    Box = "box",
    Dailymotion = "dailymotion",
    Discord = "discord",
    Disqus = "disqus",
    Dropbox = "dropbox",
    Etsy = "etsy",
    Facebook = "facebook",
    Github = "github",
    Gitlab = "gitlab",
    Google = "google",
    Linkedin = "linkedin",
    Microsoft = "microsoft",
    Notion = "notion",
    Oidc = "oidc",
    Okta = "okta",
    Paypal = "paypal",
    PaypalSandbox = "paypalSandbox",
    Podio = "podio",
    Salesforce = "salesforce",
    Slack = "slack",
    Spotify = "spotify",
    Stripe = "stripe",
    Tradeshift = "tradeshift",
    TradeshiftBox = "tradeshiftBox",
    Twitch = "twitch",
    Wordpress = "wordpress",
    Yahoo = "yahoo",
    Yammer = "yammer",
    Yandex = "yandex",
    Zoho = "zoho",
    Zoom = "zoom",
    Mock = "mock"
}

export enum Browser {
    AvantBrowser = "aa",
    AndroidWebViewBeta = "an",
    GoogleChrome = "ch",
    GoogleChromeIOS = "ci",
    GoogleChromeMobile = "cm",
    Chromium = "cr",
    MozillaFirefox = "ff",
    Safari = "sf",
    MobileSafari = "mf",
    MicrosoftEdge = "ps",
    MicrosoftEdgeIOS = "oi",
    OperaMini = "om",
    Opera = "op",
    OperaNext = "on"
}

export enum CreditCard {
    AmericanExpress = "amex",
    Argencard = "argencard",
    Cabal = "cabal",
    Cencosud = "cencosud",
    DinersClub = "diners",
    Discover = "discover",
    Elo = "elo",
    Hipercard = "hipercard",
    JCB = "jcb",
    Mastercard = "mastercard",
    Naranja = "naranja",
    TarjetaShopping = "targeta-shopping",
    UnionChinaPay = "union-china-pay",
    Visa = "visa",
    MIR = "mir",
    Maestro = "maestro"
}

export enum Flag {
    Afghanistan = "af",
    Angola = "ao",
    Albania = "al",
    Andorra = "ad",
    UnitedArabEmirates = "ae",
    Argentina = "ar",
    Armenia = "am",
    AntiguaAndBarbuda = "ag",
    Australia = "au",
    Austria = "at",
    Azerbaijan = "az",
    Burundi = "bi",
    Belgium = "be",
    Benin = "bj",
    BurkinaFaso = "bf",
    Bangladesh = "bd",
    Bulgaria = "bg",
    Bahrain = "bh",
    Bahamas = "bs",
    BosniaAndHerzegovina = "ba",
    Belarus = "by",
    Belize = "bz",
    Bolivia = "bo",
    Brazil = "br",
    Barbados = "bb",
    BruneiDarussalam = "bn",
    Bhutan = "bt",
    Botswana = "bw",
    CentralAfricanRepublic = "cf",
    Canada = "ca",
    Switzerland = "ch",
    Chile = "cl",
    China = "cn",
    CoteDIvoire = "ci",
    Cameroon = "cm",
    DemocraticRepublicOfTheCongo = "cd",
    RepublicOfTheCongo = "cg",
    Colombia = "co",
    Comoros = "km",
    CapeVerde = "cv",
    CostaRica = "cr",
    Cuba = "cu",
    Cyprus = "cy",
    CzechRepublic = "cz",
    Germany = "de",
    Djibouti = "dj",
    Dominica = "dm",
    Denmark = "dk",
    DominicanRepublic = "do",
    Algeria = "dz",
    Ecuador = "ec",
    Egypt = "eg",
    Eritrea = "er",
    Spain = "es",
    Estonia = "ee",
    Ethiopia = "et",
    Finland = "fi",
    Fiji = "fj",
    France = "fr",
    MicronesiaFederatedStatesOf = "fm",
    Gabon = "ga",
    UnitedKingdom = "gb",
    Georgia = "ge",
    Ghana = "gh",
    Guinea = "gn",
    Gambia = "gm",
    GuineaBissau = "gw",
    EquatorialGuinea = "gq",
    Greece = "gr",
    Grenada = "gd",
    Guatemala = "gt",
    Guyana = "gy",
    Honduras = "hn",
    Croatia = "hr",
    Haiti = "ht",
    Hungary = "hu",
    Indonesia = "id",
    India = "in",
    Ireland = "ie",
    IranIslamicRepublicOf = "ir",
    Iraq = "iq",
    Iceland = "is",
    Israel = "il",
    Italy = "it",
    Jamaica = "jm",
    Jordan = "jo",
    Japan = "jp",
    Kazakhstan = "kz",
    Kenya = "ke",
    Kyrgyzstan = "kg",
    Cambodia = "kh",
    Kiribati = "ki",
    SaintKittsAndNevis = "kn",
    SouthKorea = "kr",
    Kuwait = "kw",
    LaoPeopleSDemocraticRepublic = "la",
    Lebanon = "lb",
    Liberia = "lr",
    Libya = "ly",
    SaintLucia = "lc",
    Liechtenstein = "li",
    SriLanka = "lk",
    Lesotho = "ls",
    Lithuania = "lt",
    Luxembourg = "lu",
    Latvia = "lv",
    Morocco = "ma",
    Monaco = "mc",
    Moldova = "md",
    Madagascar = "mg",
    Maldives = "mv",
    Mexico = "mx",
    MarshallIslands = "mh",
    NorthMacedonia = "mk",
    Mali = "ml",
    Malta = "mt",
    Myanmar = "mm",
    Montenegro = "me",
    Mongolia = "mn",
    Mozambique = "mz",
    Mauritania = "mr",
    Mauritius = "mu",
    Malawi = "mw",
    Malaysia = "my",
    Namibia = "na",
    Niger = "ne",
    Nigeria = "ng",
    Nicaragua = "ni",
    Netherlands = "nl",
    Norway = "no",
    Nepal = "np",
    Nauru = "nr",
    NewZealand = "nz",
    Oman = "om",
    Pakistan = "pk",
    Panama = "pa",
    Peru = "pe",
    Philippines = "ph",
    Palau = "pw",
    PapuaNewGuinea = "pg",
    Poland = "pl",
    FrenchPolynesia = "pf",
    NorthKorea = "kp",
    Portugal = "pt",
    Paraguay = "py",
    Qatar = "qa",
    Romania = "ro",
    Russia = "ru",
    Rwanda = "rw",
    SaudiArabia = "sa",
    Sudan = "sd",
    Senegal = "sn",
    Singapore = "sg",
    SolomonIslands = "sb",
    SierraLeone = "sl",
    ElSalvador = "sv",
    SanMarino = "sm",
    Somalia = "so",
    Serbia = "rs",
    SouthSudan = "ss",
    SaoTomeAndPrincipe = "st",
    Suriname = "sr",
    Slovakia = "sk",
    Slovenia = "si",
    Sweden = "se",
    Eswatini = "sz",
    Seychelles = "sc",
    Syria = "sy",
    Chad = "td",
    Togo = "tg",
    Thailand = "th",
    Tajikistan = "tj",
    Turkmenistan = "tm",
    TimorLeste = "tl",
    Tonga = "to",
    TrinidadAndTobago = "tt",
    Tunisia = "tn",
    Turkey = "tr",
    Tuvalu = "tv",
    Tanzania = "tz",
    Uganda = "ug",
    Ukraine = "ua",
    Uruguay = "uy",
    UnitedStates = "us",
    Uzbekistan = "uz",
    VaticanCity = "va",
    SaintVincentAndTheGrenadines = "vc",
    Venezuela = "ve",
    Vietnam = "vn",
    Vanuatu = "vu",
    Samoa = "ws",
    Yemen = "ye",
    SouthAfrica = "za",
    Zambia = "zm",
    Zimbabwe = "zw"
}

export enum DatabaseUsageRange {
    TwentyFourHours = "24h",
    ThirtyDays = "30d",
    NinetyDays = "90d"
}

export enum RelationshipType {
    OneToOne = "oneToOne",
    ManyToOne = "manyToOne",
    ManyToMany = "manyToMany",
    OneToMany = "oneToMany"
}

export enum RelationMutate {
    Cascade = "cascade",
    Restrict = "restrict",
    SetNull = "setNull"
}

export enum IndexType {
    Key = "key",
    Fulltext = "fulltext",
    Unique = "unique"
}

export enum Runtime {
    Node145 = "node-14.5",
    Node160 = "node-16.0",
    Node180 = "node-18.0",
    Node190 = "node-19.0",
    Node200 = "node-20.0",
    Node210 = "node-21.0",
    Php80 = "php-8.0",
    Php81 = "php-8.1",
    Php82 = "php-8.2",
    Php83 = "php-8.3",
    Ruby30 = "ruby-3.0",
    Ruby31 = "ruby-3.1",
    Ruby32 = "ruby-3.2",
    Ruby33 = "ruby-3.3",
    Python38 = "python-3.8",
    Python39 = "python-3.9",
    Python310 = "python-3.10",
    Python311 = "python-3.11",
    Python312 = "python-3.12",
    Pythonml311 = "python-ml-3.11",
    Deno140 = "deno-1.40",
    Dart215 = "dart-2.15",
    Dart216 = "dart-2.16",
    Dart217 = "dart-2.17",
    Dart218 = "dart-2.18",
    Dart30 = "dart-3.0",
    Dart31 = "dart-3.1",
    Dart33 = "dart-3.3",
    Dotnet31 = "dotnet-3.1",
    Dotnet60 = "dotnet-6.0",
    Dotnet70 = "dotnet-7.0",
    Java80 = "java-8.0",
    Java110 = "java-11.0",
    Java170 = "java-17.0",
    Java180 = "java-18.0",
    Java210 = "java-21.0",
    Swift55 = "swift-5.5",
    Swift58 = "swift-5.8",
    Swift59 = "swift-5.9",
    Kotlin16 = "kotlin-1.6",
    Kotlin18 = "kotlin-1.8",
    Kotlin19 = "kotlin-1.9",
    Cpp17 = "cpp-17",
    Cpp20 = "cpp-20",
    Bun10 = "bun-1.0",
    Go123 = "go-1.23"
}

export enum FunctionUsageRange {
    TwentyFourHours = "24h",
    ThirtyDays = "30d",
    NinetyDays = "90d"
}

export enum ExecutionMethod {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    PATCH = "PATCH",
    DELETE = "DELETE",
    OPTIONS = "OPTIONS"
}

export enum Name {
    V1database = "v1-database",
    V1deletes = "v1-deletes",
    V1audits = "v1-audits",
    V1mails = "v1-mails",
    V1functions = "v1-functions",
    V1usage = "v1-usage",
    V1usagedump = "v1-usage-dump",
    V1webhooks = "v1-webhooks",
    V1certificates = "v1-certificates",
    V1builds = "v1-builds",
    V1messaging = "v1-messaging",
    V1migrations = "v1-migrations"
}

export enum SmtpEncryption {
    None = "none",
    Ssl = "ssl",
    Tls = "tls"
}

export enum ProjectUsageRange {
    OneHour = "1h",
    OneDay = "1d"
}

export enum Region {
    Default = "default",
    Fra = "fra"
}

export enum Api {
    Rest = "rest",
    Graphql = "graphql",
    Realtime = "realtime"
}

export enum AuthMethod {
    Emailpassword = "email-password",
    Magicurl = "magic-url",
    Emailotp = "email-otp",
    Anonymous = "anonymous",
    Invites = "invites",
    Jwt = "jwt",
    Phone = "phone"
}

export enum PlatformType {
    Web = "web",
    Flutterweb = "flutter-web",
    Flutterios = "flutter-ios",
    Flutterandroid = "flutter-android",
    Flutterlinux = "flutter-linux",
    Fluttermacos = "flutter-macos",
    Flutterwindows = "flutter-windows",
    Appleios = "apple-ios",
    Applemacos = "apple-macos",
    Applewatchos = "apple-watchos",
    Appletvos = "apple-tvos",
    Android = "android",
    Unity = "unity",
    Reactnativeios = "react-native-ios",
    Reactnativeandroid = "react-native-android"
}

export enum ApiService {
    Account = "account",
    Avatars = "avatars",
    Databases = "databases",
    Locale = "locale",
    Health = "health",
    Storage = "storage",
    Teams = "teams",
    Users = "users",
    Functions = "functions",
    Graphql = "graphql",
    Messaging = "messaging"
}

export enum SMTPSecure {
    Tls = "tls"
}

export enum EmailTemplateType {
    Verification = "verification",
    Magicsession = "magicsession",
    Recovery = "recovery",
    Invitation = "invitation",
    Mfachallenge = "mfachallenge",
    Sessionalert = "sessionalert",
    Otpsession = "otpsession"
}

export enum EmailTemplateLocale {
    Af = "af",
    Arae = "ar-ae",
    Arbh = "ar-bh",
    Ardz = "ar-dz",
    Areg = "ar-eg",
    Ariq = "ar-iq",
    Arjo = "ar-jo",
    Arkw = "ar-kw",
    Arlb = "ar-lb",
    Arly = "ar-ly",
    Arma = "ar-ma",
    Arom = "ar-om",
    Arqa = "ar-qa",
    Arsa = "ar-sa",
    Arsy = "ar-sy",
    Artn = "ar-tn",
    Arye = "ar-ye",
    As = "as",
    Az = "az",
    Be = "be",
    Bg = "bg",
    Bh = "bh",
    Bn = "bn",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    Deat = "de-at",
    Dech = "de-ch",
    Deli = "de-li",
    Delu = "de-lu",
    El = "el",
    En = "en",
    Enau = "en-au",
    Enbz = "en-bz",
    Enca = "en-ca",
    Engb = "en-gb",
    Enie = "en-ie",
    Enjm = "en-jm",
    Ennz = "en-nz",
    Entt = "en-tt",
    Enus = "en-us",
    Enza = "en-za",
    Eo = "eo",
    Es = "es",
    Esar = "es-ar",
    Esbo = "es-bo",
    Escl = "es-cl",
    Esco = "es-co",
    Escr = "es-cr",
    Esdo = "es-do",
    Esec = "es-ec",
    Esgt = "es-gt",
    Eshn = "es-hn",
    Esmx = "es-mx",
    Esni = "es-ni",
    Espa = "es-pa",
    Espe = "es-pe",
    Espr = "es-pr",
    Espy = "es-py",
    Essv = "es-sv",
    Esuy = "es-uy",
    Esve = "es-ve",
    Et = "et",
    Eu = "eu",
    Fa = "fa",
    Fi = "fi",
    Fo = "fo",
    Fr = "fr",
    Frbe = "fr-be",
    Frca = "fr-ca",
    Frch = "fr-ch",
    Frlu = "fr-lu",
    Ga = "ga",
    Gd = "gd",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Itch = "it-ch",
    Ja = "ja",
    Ji = "ji",
    Ko = "ko",
    Ku = "ku",
    Lt = "lt",
    Lv = "lv",
    Mk = "mk",
    Ml = "ml",
    Ms = "ms",
    Mt = "mt",
    Nb = "nb",
    Ne = "ne",
    Nl = "nl",
    Nlbe = "nl-be",
    Nn = "nn",
    No = "no",
    Pa = "pa",
    Pl = "pl",
    Pt = "pt",
    Ptbr = "pt-br",
    Rm = "rm",
    Ro = "ro",
    Romd = "ro-md",
    Ru = "ru",
    Rumd = "ru-md",
    Sb = "sb",
    Sk = "sk",
    Sl = "sl",
    Sq = "sq",
    Sr = "sr",
    Sv = "sv",
    Svfi = "sv-fi",
    Th = "th",
    Tn = "tn",
    Tr = "tr",
    Ts = "ts",
    Ua = "ua",
    Ur = "ur",
    Ve = "ve",
    Vi = "vi",
    Xh = "xh",
    Zhcn = "zh-cn",
    Zhhk = "zh-hk",
    Zhsg = "zh-sg",
    Zhtw = "zh-tw",
    Zu = "zu"
}

export enum SmsTemplateType {
    Verification = "verification",
    Login = "login",
    Invitation = "invitation",
    Mfachallenge = "mfachallenge"
}

export enum SmsTemplateLocale {
    Af = "af",
    Arae = "ar-ae",
    Arbh = "ar-bh",
    Ardz = "ar-dz",
    Areg = "ar-eg",
    Ariq = "ar-iq",
    Arjo = "ar-jo",
    Arkw = "ar-kw",
    Arlb = "ar-lb",
    Arly = "ar-ly",
    Arma = "ar-ma",
    Arom = "ar-om",
    Arqa = "ar-qa",
    Arsa = "ar-sa",
    Arsy = "ar-sy",
    Artn = "ar-tn",
    Arye = "ar-ye",
    As = "as",
    Az = "az",
    Be = "be",
    Bg = "bg",
    Bh = "bh",
    Bn = "bn",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    Deat = "de-at",
    Dech = "de-ch",
    Deli = "de-li",
    Delu = "de-lu",
    El = "el",
    En = "en",
    Enau = "en-au",
    Enbz = "en-bz",
    Enca = "en-ca",
    Engb = "en-gb",
    Enie = "en-ie",
    Enjm = "en-jm",
    Ennz = "en-nz",
    Entt = "en-tt",
    Enus = "en-us",
    Enza = "en-za",
    Eo = "eo",
    Es = "es",
    Esar = "es-ar",
    Esbo = "es-bo",
    Escl = "es-cl",
    Esco = "es-co",
    Escr = "es-cr",
    Esdo = "es-do",
    Esec = "es-ec",
    Esgt = "es-gt",
    Eshn = "es-hn",
    Esmx = "es-mx",
    Esni = "es-ni",
    Espa = "es-pa",
    Espe = "es-pe",
    Espr = "es-pr",
    Espy = "es-py",
    Essv = "es-sv",
    Esuy = "es-uy",
    Esve = "es-ve",
    Et = "et",
    Eu = "eu",
    Fa = "fa",
    Fi = "fi",
    Fo = "fo",
    Fr = "fr",
    Frbe = "fr-be",
    Frca = "fr-ca",
    Frch = "fr-ch",
    Frlu = "fr-lu",
    Ga = "ga",
    Gd = "gd",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Itch = "it-ch",
    Ja = "ja",
    Ji = "ji",
    Ko = "ko",
    Ku = "ku",
    Lt = "lt",
    Lv = "lv",
    Mk = "mk",
    Ml = "ml",
    Ms = "ms",
    Mt = "mt",
    Nb = "nb",
    Ne = "ne",
    Nl = "nl",
    Nlbe = "nl-be",
    Nn = "nn",
    No = "no",
    Pa = "pa",
    Pl = "pl",
    Pt = "pt",
    Ptbr = "pt-br",
    Rm = "rm",
    Ro = "ro",
    Romd = "ro-md",
    Ru = "ru",
    Rumd = "ru-md",
    Sb = "sb",
    Sk = "sk",
    Sl = "sl",
    Sq = "sq",
    Sr = "sr",
    Sv = "sv",
    Svfi = "sv-fi",
    Th = "th",
    Tn = "tn",
    Tr = "tr",
    Ts = "ts",
    Ua = "ua",
    Ur = "ur",
    Ve = "ve",
    Vi = "vi",
    Xh = "xh",
    Zhcn = "zh-cn",
    Zhhk = "zh-hk",
    Zhsg = "zh-sg",
    Zhtw = "zh-tw",
    Zu = "zu"
}

export enum ResourceType {
    Api = "api",
    Function = "function"
}

export enum Compression {
    None = "none",
    Gzip = "gzip",
    Zstd = "zstd"
}

export enum ImageGravity {
    Center = "center",
    Topleft = "top-left",
    Top = "top",
    Topright = "top-right",
    Left = "left",
    Right = "right",
    Bottomleft = "bottom-left",
    Bottom = "bottom",
    Bottomright = "bottom-right"
}

export enum ImageFormat {
    Jpg = "jpg",
    Jpeg = "jpeg",
    Gif = "gif",
    Png = "png",
    Webp = "webp"
}

export enum StorageUsageRange {
    TwentyFourHours = "24h",
    ThirtyDays = "30d",
    NinetyDays = "90d"
}

export enum PasswordHash {
    Sha1 = "sha1",
    Sha224 = "sha224",
    Sha256 = "sha256",
    Sha384 = "sha384",
    Sha512224 = "sha512/224",
    Sha512256 = "sha512/256",
    Sha512 = "sha512",
    Sha3224 = "sha3-224",
    Sha3256 = "sha3-256",
    Sha3384 = "sha3-384",
    Sha3512 = "sha3-512"
}

export enum UserUsageRange {
    TwentyFourHours = "24h",
    ThirtyDays = "30d",
    NinetyDays = "90d"
}

export enum MessagingProviderType {
    Email = "email",
    Sms = "sms",
    Push = "push"
}

/**
    * Appconda Models
    */
export namespace Models {
        /**
            * Documents List
            */
        type DocumentList<Document extends Models.Document> = {
                /**
                    * Total number of documents documents that matched your query.
                    */
                total: number;
                /**
                    * List of documents.
                    */
                documents: Document[];
        };
        /**
            * Collections List
            */
        type CollectionList = {
                /**
                    * Total number of collections documents that matched your query.
                    */
                total: number;
                /**
                    * List of collections.
                    */
                collections: Collection[];
        };
        /**
            * Databases List
            */
        type DatabaseList = {
                /**
                    * Total number of databases documents that matched your query.
                    */
                total: number;
                /**
                    * List of databases.
                    */
                databases: Database[];
        };
        /**
            * Indexes List
            */
        type IndexList = {
                /**
                    * Total number of indexes documents that matched your query.
                    */
                total: number;
                /**
                    * List of indexes.
                    */
                indexes: Index[];
        };
        /**
            * Users List
            */
        type UserList<Preferences extends Models.Preferences> = {
                /**
                    * Total number of users documents that matched your query.
                    */
                total: number;
                /**
                    * List of users.
                    */
                users: User<Preferences>[];
        };
        /**
            * Sessions List
            */
        type SessionList = {
                /**
                    * Total number of sessions documents that matched your query.
                    */
                total: number;
                /**
                    * List of sessions.
                    */
                sessions: Session[];
        };
        /**
            * Identities List
            */
        type IdentityList = {
                /**
                    * Total number of identities documents that matched your query.
                    */
                total: number;
                /**
                    * List of identities.
                    */
                identities: Identity[];
        };
        /**
            * Logs List
            */
        type LogList = {
                /**
                    * Total number of logs documents that matched your query.
                    */
                total: number;
                /**
                    * List of logs.
                    */
                logs: Log[];
        };
        /**
            * Files List
            */
        type FileList = {
                /**
                    * Total number of files documents that matched your query.
                    */
                total: number;
                /**
                    * List of files.
                    */
                files: File[];
        };
        /**
            * Buckets List
            */
        type BucketList = {
                /**
                    * Total number of buckets documents that matched your query.
                    */
                total: number;
                /**
                    * List of buckets.
                    */
                buckets: Bucket[];
        };
        /**
            * Teams List
            */
        type TeamList<Preferences extends Models.Preferences> = {
                /**
                    * Total number of teams documents that matched your query.
                    */
                total: number;
                /**
                    * List of teams.
                    */
                teams: Team<Preferences>[];
        };
        /**
            * Memberships List
            */
        type MembershipList = {
                /**
                    * Total number of memberships documents that matched your query.
                    */
                total: number;
                /**
                    * List of memberships.
                    */
                memberships: Membership[];
        };
        /**
            * Functions List
            */
        type FunctionList = {
                /**
                    * Total number of functions documents that matched your query.
                    */
                total: number;
                /**
                    * List of functions.
                    */
                functions: Function[];
        };
        /**
            * Function Templates List
            */
        type TemplateFunctionList = {
                /**
                    * Total number of templates documents that matched your query.
                    */
                total: number;
                /**
                    * List of templates.
                    */
                templates: TemplateFunction[];
        };
        /**
            * Installations List
            */
        type InstallationList = {
                /**
                    * Total number of installations documents that matched your query.
                    */
                total: number;
                /**
                    * List of installations.
                    */
                installations: Installation[];
        };
        /**
            * Provider Repositories List
            */
        type ProviderRepositoryList = {
                /**
                    * Total number of providerRepositories documents that matched your query.
                    */
                total: number;
                /**
                    * List of providerRepositories.
                    */
                providerRepositories: ProviderRepository[];
        };
        /**
            * Branches List
            */
        type BranchList = {
                /**
                    * Total number of branches documents that matched your query.
                    */
                total: number;
                /**
                    * List of branches.
                    */
                branches: Branch[];
        };
        /**
            * Runtimes List
            */
        type RuntimeList = {
                /**
                    * Total number of runtimes documents that matched your query.
                    */
                total: number;
                /**
                    * List of runtimes.
                    */
                runtimes: Runtime[];
        };
        /**
            * Deployments List
            */
        type DeploymentList = {
                /**
                    * Total number of deployments documents that matched your query.
                    */
                total: number;
                /**
                    * List of deployments.
                    */
                deployments: Deployment[];
        };
        /**
            * Executions List
            */
        type ExecutionList = {
                /**
                    * Total number of executions documents that matched your query.
                    */
                total: number;
                /**
                    * List of executions.
                    */
                executions: Execution[];
        };
        /**
            * Projects List
            */
        type ProjectList = {
                /**
                    * Total number of projects documents that matched your query.
                    */
                total: number;
                /**
                    * List of projects.
                    */
                projects: Project[];
        };
        /**
            * Webhooks List
            */
        type WebhookList = {
                /**
                    * Total number of webhooks documents that matched your query.
                    */
                total: number;
                /**
                    * List of webhooks.
                    */
                webhooks: Webhook[];
        };
        /**
            * API Keys List
            */
        type KeyList = {
                /**
                    * Total number of keys documents that matched your query.
                    */
                total: number;
                /**
                    * List of keys.
                    */
                keys: Key[];
        };
        /**
            * Platforms List
            */
        type PlatformList = {
                /**
                    * Total number of platforms documents that matched your query.
                    */
                total: number;
                /**
                    * List of platforms.
                    */
                platforms: Platform[];
        };
        /**
            * Countries List
            */
        type CountryList = {
                /**
                    * Total number of countries documents that matched your query.
                    */
                total: number;
                /**
                    * List of countries.
                    */
                countries: Country[];
        };
        /**
            * Continents List
            */
        type ContinentList = {
                /**
                    * Total number of continents documents that matched your query.
                    */
                total: number;
                /**
                    * List of continents.
                    */
                continents: Continent[];
        };
        /**
            * Languages List
            */
        type LanguageList = {
                /**
                    * Total number of languages documents that matched your query.
                    */
                total: number;
                /**
                    * List of languages.
                    */
                languages: Language[];
        };
        /**
            * Currencies List
            */
        type CurrencyList = {
                /**
                    * Total number of currencies documents that matched your query.
                    */
                total: number;
                /**
                    * List of currencies.
                    */
                currencies: Currency[];
        };
        /**
            * Phones List
            */
        type PhoneList = {
                /**
                    * Total number of phones documents that matched your query.
                    */
                total: number;
                /**
                    * List of phones.
                    */
                phones: Phone[];
        };
        /**
            * Variables List
            */
        type VariableList = {
                /**
                    * Total number of variables documents that matched your query.
                    */
                total: number;
                /**
                    * List of variables.
                    */
                variables: Variable[];
        };
        /**
            * Rule List
            */
        type ProxyRuleList = {
                /**
                    * Total number of rules documents that matched your query.
                    */
                total: number;
                /**
                    * List of rules.
                    */
                rules: ProxyRule[];
        };
        /**
            * Locale codes list
            */
        type LocaleCodeList = {
                /**
                    * Total number of localeCodes documents that matched your query.
                    */
                total: number;
                /**
                    * List of localeCodes.
                    */
                localeCodes: LocaleCode[];
        };
        /**
            * Provider list
            */
        type ProviderList = {
                /**
                    * Total number of providers documents that matched your query.
                    */
                total: number;
                /**
                    * List of providers.
                    */
                providers: Provider[];
        };
        /**
            * Message list
            */
        type MessageList = {
                /**
                    * Total number of messages documents that matched your query.
                    */
                total: number;
                /**
                    * List of messages.
                    */
                messages: Message[];
        };
        /**
            * Topic list
            */
        type TopicList = {
                /**
                    * Total number of topics documents that matched your query.
                    */
                total: number;
                /**
                    * List of topics.
                    */
                topics: Topic[];
        };
        /**
            * Subscriber list
            */
        type SubscriberList = {
                /**
                    * Total number of subscribers documents that matched your query.
                    */
                total: number;
                /**
                    * List of subscribers.
                    */
                subscribers: Subscriber[];
        };
        /**
            * Target list
            */
        type TargetList = {
                /**
                    * Total number of targets documents that matched your query.
                    */
                total: number;
                /**
                    * List of targets.
                    */
                targets: Target[];
        };
        /**
            * Migrations List
            */
        type MigrationList = {
                /**
                    * Total number of migrations documents that matched your query.
                    */
                total: number;
                /**
                    * List of migrations.
                    */
                migrations: Migration[];
        };
        /**
            * Migrations Firebase Projects List
            */
        type FirebaseProjectList = {
                /**
                    * Total number of projects documents that matched your query.
                    */
                total: number;
                /**
                    * List of projects.
                    */
                projects: FirebaseProject[];
        };
        /**
            * Specifications List
            */
        type SpecificationList = {
                /**
                    * Total number of specifications documents that matched your query.
                    */
                total: number;
                /**
                    * List of specifications.
                    */
                specifications: Specification[];
        };
        /**
            * VCS Content List
            */
        type VcsContentList = {
                /**
                    * Total number of contents documents that matched your query.
                    */
                total: number;
                /**
                    * List of contents.
                    */
                contents: VcsContent[];
        };
        /**
            * Database
            */
        type Database = {
                /**
                    * Database ID.
                    */
                $id: string;
                /**
                    * Database name.
                    */
                name: string;
                /**
                    * Database creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Database update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * If database is enabled. Can be &#039;enabled&#039; or &#039;disabled&#039;. When disabled, the database is inaccessible to users, but remains accessible to Server SDKs using API keys.
                    */
                enabled: boolean;
        };
        /**
            * Collection
            */
        type Collection = {
                /**
                    * Collection ID.
                    */
                $id: string;
                /**
                    * Collection creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Collection update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Collection permissions. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                $permissions: string[];
                /**
                    * Database ID.
                    */
                databaseId: string;
                /**
                    * Collection name.
                    */
                name: string;
                /**
                    * Collection enabled. Can be &#039;enabled&#039; or &#039;disabled&#039;. When disabled, the collection is inaccessible to users, but remains accessible to Server SDKs using API keys.
                    */
                enabled: boolean;
                /**
                    * Whether document-level permissions are enabled. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                documentSecurity: boolean;
                /**
                    * Collection attributes.
                    */
                attributes: string[];
                /**
                    * Collection indexes.
                    */
                indexes: Index[];
        };
        /**
            * Attributes List
            */
        type AttributeList = {
                /**
                    * Total number of attributes in the given collection.
                    */
                total: number;
                /**
                    * List of attributes.
                    */
                attributes: string[];
        };
        /**
            * AttributeString
            */
        type AttributeString = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * Attribute size.
                    */
                size: number;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: string;
        };
        /**
            * AttributeInteger
            */
        type AttributeInteger = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * Minimum value to enforce for new documents.
                    */
                min?: number;
                /**
                    * Maximum value to enforce for new documents.
                    */
                max?: number;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: number;
        };
        /**
            * AttributeFloat
            */
        type AttributeFloat = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * Minimum value to enforce for new documents.
                    */
                min?: number;
                /**
                    * Maximum value to enforce for new documents.
                    */
                max?: number;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: number;
        };
        /**
            * AttributeBoolean
            */
        type AttributeBoolean = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: boolean;
        };
        /**
            * AttributeEmail
            */
        type AttributeEmail = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * String format.
                    */
                format: string;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: string;
        };
        /**
            * AttributeEnum
            */
        type AttributeEnum = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * Array of elements in enumerated type.
                    */
                elements: string[];
                /**
                    * String format.
                    */
                format: string;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: string;
        };
        /**
            * AttributeIP
            */
        type AttributeIp = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * String format.
                    */
                format: string;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: string;
        };
        /**
            * AttributeURL
            */
        type AttributeUrl = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * String format.
                    */
                format: string;
                /**
                    * Default value for attribute when not provided. Cannot be set when attribute is required.
                    */
                default?: string;
        };
        /**
            * AttributeDatetime
            */
        type AttributeDatetime = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * ISO 8601 format.
                    */
                format: string;
                /**
                    * Default value for attribute when not provided. Only null is optional
                    */
                default?: string;
        };
        /**
            * AttributeRelationship
            */
        type AttributeRelationship = {
                /**
                    * Attribute Key.
                    */
                key: string;
                /**
                    * Attribute type.
                    */
                type: string;
                /**
                    * Attribute status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an attribute.
                    */
                error: string;
                /**
                    * Is attribute required?
                    */
                required: boolean;
                /**
                    * Is attribute an array?
                    */
                array?: boolean;
                /**
                    * The ID of the related collection.
                    */
                relatedCollection: string;
                /**
                    * The type of the relationship.
                    */
                relationType: string;
                /**
                    * Is the relationship two-way?
                    */
                twoWay: boolean;
                /**
                    * The key of the two-way relationship.
                    */
                twoWayKey: string;
                /**
                    * How deleting the parent document will propagate to child documents.
                    */
                onDelete: string;
                /**
                    * Whether this is the parent or child side of the relationship
                    */
                side: string;
        };
        /**
            * Index
            */
        type Index = {
                /**
                    * Index Key.
                    */
                key: string;
                /**
                    * Index type.
                    */
                type: string;
                /**
                    * Index status. Possible values: `available`, `processing`, `deleting`, `stuck`, or `failed`
                    */
                status: string;
                /**
                    * Error message. Displays error generated on failure of creating or deleting an index.
                    */
                error: string;
                /**
                    * Index attributes.
                    */
                attributes: string[];
                /**
                    * Index orders.
                    */
                orders?: string[];
        };
        /**
            * Document
            */
        type Document = {
                /**
                    * Document ID.
                    */
                $id: string;
                /**
                    * Collection ID.
                    */
                $collectionId: string;
                /**
                    * Database ID.
                    */
                $databaseId: string;
                /**
                    * Document creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Document update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Document permissions. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                $permissions: string[];
                [key: string]: any;
        };
        /**
            * Log
            */
        type Log = {
                /**
                    * Event name.
                    */
                event: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * User Email.
                    */
                userEmail: string;
                /**
                    * User Name.
                    */
                userName: string;
                /**
                    * API mode when event triggered.
                    */
                mode: string;
                /**
                    * IP session in use when the session was created.
                    */
                ip: string;
                /**
                    * Log creation date in ISO 8601 format.
                    */
                time: string;
                /**
                    * Operating system code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/os.json).
                    */
                osCode: string;
                /**
                    * Operating system name.
                    */
                osName: string;
                /**
                    * Operating system version.
                    */
                osVersion: string;
                /**
                    * Client type.
                    */
                clientType: string;
                /**
                    * Client code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/clients.json).
                    */
                clientCode: string;
                /**
                    * Client name.
                    */
                clientName: string;
                /**
                    * Client version.
                    */
                clientVersion: string;
                /**
                    * Client engine name.
                    */
                clientEngine: string;
                /**
                    * Client engine name.
                    */
                clientEngineVersion: string;
                /**
                    * Device name.
                    */
                deviceName: string;
                /**
                    * Device brand name.
                    */
                deviceBrand: string;
                /**
                    * Device model name.
                    */
                deviceModel: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                countryCode: string;
                /**
                    * Country name.
                    */
                countryName: string;
        };
        /**
            * User
            */
        type User<Preferences extends Models.Preferences> = {
                /**
                    * User ID.
                    */
                $id: string;
                /**
                    * User creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * User update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User name.
                    */
                name: string;
                /**
                    * Hashed user password.
                    */
                password?: string;
                /**
                    * Password hashing algorithm.
                    */
                hash?: string;
                /**
                    * Password hashing algorithm configuration.
                    */
                hashOptions?: object;
                /**
                    * User registration date in ISO 8601 format.
                    */
                registration: string;
                /**
                    * User status. Pass `true` for enabled and `false` for disabled.
                    */
                status: boolean;
                /**
                    * Labels for the user.
                    */
                labels: string[];
                /**
                    * Password update time in ISO 8601 format.
                    */
                passwordUpdate: string;
                /**
                    * User email address.
                    */
                email: string;
                /**
                    * User phone number in E.164 format.
                    */
                phone: string;
                /**
                    * Email verification status.
                    */
                emailVerification: boolean;
                /**
                    * Phone verification status.
                    */
                phoneVerification: boolean;
                /**
                    * Multi factor authentication status.
                    */
                mfa: boolean;
                /**
                    * User preferences as a key-value object
                    */
                prefs: Preferences;
                /**
                    * A user-owned message receiver. A single user may have multiple e.g. emails, phones, and a browser. Each target is registered with a single provider.
                    */
                targets: Target[];
                /**
                    * Most recent access date in ISO 8601 format. This attribute is only updated again after 24 hours.
                    */
                accessedAt: string;
        };
        /**
            * AlgoMD5
            */
        type AlgoMd5 = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoSHA
            */
        type AlgoSha = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoPHPass
            */
        type AlgoPhpass = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoBcrypt
            */
        type AlgoBcrypt = {
                /**
                    * Algo type.
                    */
                type: string;
        };
        /**
            * AlgoScrypt
            */
        type AlgoScrypt = {
                /**
                    * Algo type.
                    */
                type: string;
                /**
                    * CPU complexity of computed hash.
                    */
                costCpu: number;
                /**
                    * Memory complexity of computed hash.
                    */
                costMemory: number;
                /**
                    * Parallelization of computed hash.
                    */
                costParallel: number;
                /**
                    * Length used to compute hash.
                    */
                length: number;
        };
        /**
            * AlgoScryptModified
            */
        type AlgoScryptModified = {
                /**
                    * Algo type.
                    */
                type: string;
                /**
                    * Salt used to compute hash.
                    */
                salt: string;
                /**
                    * Separator used to compute hash.
                    */
                saltSeparator: string;
                /**
                    * Key used to compute hash.
                    */
                signerKey: string;
        };
        /**
            * AlgoArgon2
            */
        type AlgoArgon2 = {
                /**
                    * Algo type.
                    */
                type: string;
                /**
                    * Memory used to compute hash.
                    */
                memoryCost: number;
                /**
                    * Amount of time consumed to compute hash
                    */
                timeCost: number;
                /**
                    * Number of threads used to compute hash.
                    */
                threads: number;
        };
        /**
            * Preferences
            */
        type Preferences = {
                [key: string]: any;
        };
        /**
            * Session
            */
        type Session = {
                /**
                    * Session ID.
                    */
                $id: string;
                /**
                    * Session creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Session update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Session expiration date in ISO 8601 format.
                    */
                expire: string;
                /**
                    * Session Provider.
                    */
                provider: string;
                /**
                    * Session Provider User ID.
                    */
                providerUid: string;
                /**
                    * Session Provider Access Token.
                    */
                providerAccessToken: string;
                /**
                    * The date of when the access token expires in ISO 8601 format.
                    */
                providerAccessTokenExpiry: string;
                /**
                    * Session Provider Refresh Token.
                    */
                providerRefreshToken: string;
                /**
                    * IP in use when the session was created.
                    */
                ip: string;
                /**
                    * Operating system code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/os.json).
                    */
                osCode: string;
                /**
                    * Operating system name.
                    */
                osName: string;
                /**
                    * Operating system version.
                    */
                osVersion: string;
                /**
                    * Client type.
                    */
                clientType: string;
                /**
                    * Client code name. View list of [available options](https://github.com/appconda/appconda/blob/master/docs/lists/clients.json).
                    */
                clientCode: string;
                /**
                    * Client name.
                    */
                clientName: string;
                /**
                    * Client version.
                    */
                clientVersion: string;
                /**
                    * Client engine name.
                    */
                clientEngine: string;
                /**
                    * Client engine name.
                    */
                clientEngineVersion: string;
                /**
                    * Device name.
                    */
                deviceName: string;
                /**
                    * Device brand name.
                    */
                deviceBrand: string;
                /**
                    * Device model name.
                    */
                deviceModel: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                countryCode: string;
                /**
                    * Country name.
                    */
                countryName: string;
                /**
                    * Returns true if this the current user session.
                    */
                current: boolean;
                /**
                    * Returns a list of active session factors.
                    */
                factors: string[];
                /**
                    * Secret used to authenticate the user. Only included if the request was made with an API key
                    */
                secret: string;
                /**
                    * Most recent date in ISO 8601 format when the session successfully passed MFA challenge.
                    */
                mfaUpdatedAt: string;
        };
        /**
            * Identity
            */
        type Identity = {
                /**
                    * Identity ID.
                    */
                $id: string;
                /**
                    * Identity creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Identity update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Identity Provider.
                    */
                provider: string;
                /**
                    * ID of the User in the Identity Provider.
                    */
                providerUid: string;
                /**
                    * Email of the User in the Identity Provider.
                    */
                providerEmail: string;
                /**
                    * Identity Provider Access Token.
                    */
                providerAccessToken: string;
                /**
                    * The date of when the access token expires in ISO 8601 format.
                    */
                providerAccessTokenExpiry: string;
                /**
                    * Identity Provider Refresh Token.
                    */
                providerRefreshToken: string;
        };
        /**
            * Token
            */
        type Token = {
                /**
                    * Token ID.
                    */
                $id: string;
                /**
                    * Token creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Token secret key. This will return an empty string unless the response is returned using an API key or as part of a webhook payload.
                    */
                secret: string;
                /**
                    * Token expiration date in ISO 8601 format.
                    */
                expire: string;
                /**
                    * Security phrase of a token. Empty if security phrase was not requested when creating a token. It includes randomly generated phrase which is also sent in the external resource such as email.
                    */
                phrase: string;
        };
        /**
            * JWT
            */
        type Jwt = {
                /**
                    * JWT encoded string.
                    */
                jwt: string;
        };
        /**
            * Locale
            */
        type Locale = {
                /**
                    * User IP address.
                    */
                ip: string;
                /**
                    * Country code in [ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1) two-character format
                    */
                countryCode: string;
                /**
                    * Country name. This field support localization.
                    */
                country: string;
                /**
                    * Continent code. A two character continent code &quot;AF&quot; for Africa, &quot;AN&quot; for Antarctica, &quot;AS&quot; for Asia, &quot;EU&quot; for Europe, &quot;NA&quot; for North America, &quot;OC&quot; for Oceania, and &quot;SA&quot; for South America.
                    */
                continentCode: string;
                /**
                    * Continent name. This field support localization.
                    */
                continent: string;
                /**
                    * True if country is part of the European Union.
                    */
                eu: boolean;
                /**
                    * Currency code in [ISO 4217-1](http://en.wikipedia.org/wiki/ISO_4217) three-character format
                    */
                currency: string;
        };
        /**
            * LocaleCode
            */
        type LocaleCode = {
                /**
                    * Locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)
                    */
                code: string;
                /**
                    * Locale name
                    */
                name: string;
        };
        /**
            * File
            */
        type File = {
                /**
                    * File ID.
                    */
                $id: string;
                /**
                    * Bucket ID.
                    */
                bucketId: string;
                /**
                    * File creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * File update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * File permissions. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                $permissions: string[];
                /**
                    * File name.
                    */
                name: string;
                /**
                    * File MD5 signature.
                    */
                signature: string;
                /**
                    * File mime type.
                    */
                mimeType: string;
                /**
                    * File original size in bytes.
                    */
                sizeOriginal: number;
                /**
                    * Total number of chunks available
                    */
                chunksTotal: number;
                /**
                    * Total number of chunks uploaded
                    */
                chunksUploaded: number;
        };
        /**
            * Bucket
            */
        type Bucket = {
                /**
                    * Bucket ID.
                    */
                $id: string;
                /**
                    * Bucket creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Bucket update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Bucket permissions. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                $permissions: string[];
                /**
                    * Whether file-level security is enabled. [Learn more about permissions](https://appconda.io/docs/permissions).
                    */
                fileSecurity: boolean;
                /**
                    * Bucket name.
                    */
                name: string;
                /**
                    * Bucket enabled.
                    */
                enabled: boolean;
                /**
                    * Maximum file size supported.
                    */
                maximumFileSize: number;
                /**
                    * Allowed file extensions.
                    */
                allowedFileExtensions: string[];
                /**
                    * Compression algorithm choosen for compression. Will be one of none, [gzip](https://en.wikipedia.org/wiki/Gzip), or [zstd](https://en.wikipedia.org/wiki/Zstd).
                    */
                compression: string;
                /**
                    * Bucket is encrypted.
                    */
                encryption: boolean;
                /**
                    * Virus scanning is enabled.
                    */
                antivirus: boolean;
        };
        /**
            * Team
            */
        type Team<Preferences extends Models.Preferences> = {
                /**
                    * Team ID.
                    */
                $id: string;
                /**
                    * Team creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Team update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Team name.
                    */
                name: string;
                /**
                    * Total number of team members.
                    */
                total: number;
                /**
                    * Team preferences as a key-value object
                    */
                prefs: Preferences;
        };
        /**
            * Membership
            */
        type Membership = {
                /**
                    * Membership ID.
                    */
                $id: string;
                /**
                    * Membership creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Membership update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * User name.
                    */
                userName: string;
                /**
                    * User email address.
                    */
                userEmail: string;
                /**
                    * Team ID.
                    */
                teamId: string;
                /**
                    * Team name.
                    */
                teamName: string;
                /**
                    * Date, the user has been invited to join the team in ISO 8601 format.
                    */
                invited: string;
                /**
                    * Date, the user has accepted the invitation to join the team in ISO 8601 format.
                    */
                joined: string;
                /**
                    * User confirmation status, true if the user has joined the team or false otherwise.
                    */
                confirm: boolean;
                /**
                    * Multi factor authentication status, true if the user has MFA enabled or false otherwise.
                    */
                mfa: boolean;
                /**
                    * User list of roles
                    */
                roles: string[];
        };
        /**
            * Function
            */
        type Function = {
                /**
                    * Function ID.
                    */
                $id: string;
                /**
                    * Function creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Function update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Execution permissions.
                    */
                execute: string[];
                /**
                    * Function name.
                    */
                name: string;
                /**
                    * Function enabled.
                    */
                enabled: boolean;
                /**
                    * Is the function deployed with the latest configuration? This is set to false if you&#039;ve changed an environment variables, entrypoint, commands, or other settings that needs redeploy to be applied. When the value is false, redeploy the function to update it with the latest configuration.
                    */
                live: boolean;
                /**
                    * Whether executions will be logged. When set to false, executions will not be logged, but will reduce resource used by your Appconda project.
                    */
                logging: boolean;
                /**
                    * Function execution runtime.
                    */
                runtime: string;
                /**
                    * Function&#039;s active deployment ID.
                    */
                deployment: string;
                /**
                    * Allowed permission scopes.
                    */
                scopes: string[];
                /**
                    * Function variables.
                    */
                vars: Variable[];
                /**
                    * Function trigger events.
                    */
                events: string[];
                /**
                    * Function execution schedult in CRON format.
                    */
                schedule: string;
                /**
                    * Function execution timeout in seconds.
                    */
                timeout: number;
                /**
                    * The entrypoint file used to execute the deployment.
                    */
                entrypoint: string;
                /**
                    * The build command used to build the deployment.
                    */
                commands: string;
                /**
                    * Version of Open Runtimes used for the function.
                    */
                version: string;
                /**
                    * Function VCS (Version Control System) installation id.
                    */
                installationId: string;
                /**
                    * VCS (Version Control System) Repository ID
                    */
                providerRepositoryId: string;
                /**
                    * VCS (Version Control System) branch name
                    */
                providerBranch: string;
                /**
                    * Path to function in VCS (Version Control System) repository
                    */
                providerRootDirectory: string;
                /**
                    * Is VCS (Version Control System) connection is in silent mode? When in silence mode, no comments will be posted on the repository pull or merge requests
                    */
                providerSilentMode: boolean;
                /**
                    * Machine specification for builds and executions.
                    */
                specification: string;
        };
        /**
            * Template Function
            */
        type TemplateFunction = {
                /**
                    * Function Template Icon.
                    */
                icon: string;
                /**
                    * Function Template ID.
                    */
                id: string;
                /**
                    * Function Template Name.
                    */
                name: string;
                /**
                    * Function Template Tagline.
                    */
                tagline: string;
                /**
                    * Execution permissions.
                    */
                permissions: string[];
                /**
                    * Function trigger events.
                    */
                events: string[];
                /**
                    * Function execution schedult in CRON format.
                    */
                cron: string;
                /**
                    * Function execution timeout in seconds.
                    */
                timeout: number;
                /**
                    * Function use cases.
                    */
                useCases: string[];
                /**
                    * List of runtimes that can be used with this template.
                    */
                runtimes: TemplateRuntime[];
                /**
                    * Function Template Instructions.
                    */
                instructions: string;
                /**
                    * VCS (Version Control System) Provider.
                    */
                vcsProvider: string;
                /**
                    * VCS (Version Control System) Repository ID
                    */
                providerRepositoryId: string;
                /**
                    * VCS (Version Control System) Owner.
                    */
                providerOwner: string;
                /**
                    * VCS (Version Control System) branch version (tag).
                    */
                providerVersion: string;
                /**
                    * Function variables.
                    */
                variables: TemplateVariable[];
                /**
                    * Function scopes.
                    */
                scopes: string[];
        };
        /**
            * Template Runtime
            */
        type TemplateRuntime = {
                /**
                    * Runtime Name.
                    */
                name: string;
                /**
                    * The build command used to build the deployment.
                    */
                commands: string;
                /**
                    * The entrypoint file used to execute the deployment.
                    */
                entrypoint: string;
                /**
                    * Path to function in VCS (Version Control System) repository
                    */
                providerRootDirectory: string;
        };
        /**
            * Template Variable
            */
        type TemplateVariable = {
                /**
                    * Variable Name.
                    */
                name: string;
                /**
                    * Variable Description.
                    */
                description: string;
                /**
                    * Variable Value.
                    */
                value: string;
                /**
                    * Variable Placeholder.
                    */
                placeholder: string;
                /**
                    * Is the variable required?
                    */
                required: boolean;
                /**
                    * Variable Type.
                    */
                type: string;
        };
        /**
            * Installation
            */
        type Installation = {
                /**
                    * Function ID.
                    */
                $id: string;
                /**
                    * Function creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Function update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * VCS (Version Control System) provider name.
                    */
                provider: string;
                /**
                    * VCS (Version Control System) organization name.
                    */
                organization: string;
                /**
                    * VCS (Version Control System) installation ID.
                    */
                providerInstallationId: string;
        };
        /**
            * ProviderRepository
            */
        type ProviderRepository = {
                /**
                    * VCS (Version Control System) repository ID.
                    */
                id: string;
                /**
                    * VCS (Version Control System) repository name.
                    */
                name: string;
                /**
                    * VCS (Version Control System) organization name
                    */
                organization: string;
                /**
                    * VCS (Version Control System) provider name.
                    */
                provider: string;
                /**
                    * Is VCS (Version Control System) repository private?
                    */
                private: boolean;
                /**
                    * Auto-detected runtime suggestion. Empty if getting response of getRuntime().
                    */
                runtime: string;
                /**
                    * Last commit date in ISO 8601 format.
                    */
                pushedAt: string;
        };
        /**
            * Detection
            */
        type Detection = {
                /**
                    * Runtime
                    */
                runtime: string;
        };
        /**
            * VcsContents
            */
        type VcsContent = {
                /**
                    * Content size in bytes. Only files have size, and for directories, 0 is returned.
                    */
                size?: number;
                /**
                    * If a content is a directory. Directories can be used to check nested contents.
                    */
                isDirectory?: boolean;
                /**
                    * Name of directory or file.
                    */
                name: string;
        };
        /**
            * Branch
            */
        type Branch = {
                /**
                    * Branch Name.
                    */
                name: string;
        };
        /**
            * Runtime
            */
        type Runtime = {
                /**
                    * Runtime ID.
                    */
                $id: string;
                /**
                    * Parent runtime key.
                    */
                key: string;
                /**
                    * Runtime Name.
                    */
                name: string;
                /**
                    * Runtime version.
                    */
                version: string;
                /**
                    * Base Docker image used to build the runtime.
                    */
                base: string;
                /**
                    * Image name of Docker Hub.
                    */
                image: string;
                /**
                    * Name of the logo image.
                    */
                logo: string;
                /**
                    * List of supported architectures.
                    */
                supports: string[];
        };
        /**
            * Deployment
            */
        type Deployment = {
                /**
                    * Deployment ID.
                    */
                $id: string;
                /**
                    * Deployment creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Deployment update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Type of deployment.
                    */
                type: string;
                /**
                    * Resource ID.
                    */
                resourceId: string;
                /**
                    * Resource type.
                    */
                resourceType: string;
                /**
                    * The entrypoint file to use to execute the deployment code.
                    */
                entrypoint: string;
                /**
                    * The code size in bytes.
                    */
                size: number;
                /**
                    * The build output size in bytes.
                    */
                buildSize: number;
                /**
                    * The current build ID.
                    */
                buildId: string;
                /**
                    * Whether the deployment should be automatically activated.
                    */
                activate: boolean;
                /**
                    * The deployment status. Possible values are &quot;processing&quot;, &quot;building&quot;, &quot;waiting&quot;, &quot;ready&quot;, and &quot;failed&quot;.
                    */
                status: string;
                /**
                    * The build logs.
                    */
                buildLogs: string;
                /**
                    * The current build time in seconds.
                    */
                buildTime: number;
                /**
                    * The name of the vcs provider repository
                    */
                providerRepositoryName: string;
                /**
                    * The name of the vcs provider repository owner
                    */
                providerRepositoryOwner: string;
                /**
                    * The url of the vcs provider repository
                    */
                providerRepositoryUrl: string;
                /**
                    * The branch of the vcs repository
                    */
                providerBranch: string;
                /**
                    * The commit hash of the vcs commit
                    */
                providerCommitHash: string;
                /**
                    * The url of vcs commit author
                    */
                providerCommitAuthorUrl: string;
                /**
                    * The name of vcs commit author
                    */
                providerCommitAuthor: string;
                /**
                    * The commit message
                    */
                providerCommitMessage: string;
                /**
                    * The url of the vcs commit
                    */
                providerCommitUrl: string;
                /**
                    * The branch of the vcs repository
                    */
                providerBranchUrl: string;
        };
        /**
            * Execution
            */
        type Execution = {
                /**
                    * Execution ID.
                    */
                $id: string;
                /**
                    * Execution creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Execution upate date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Execution roles.
                    */
                $permissions: string[];
                /**
                    * Function ID.
                    */
                functionId: string;
                /**
                    * The trigger that caused the function to execute. Possible values can be: `http`, `schedule`, or `event`.
                    */
                trigger: string;
                /**
                    * The status of the function execution. Possible values can be: `waiting`, `processing`, `completed`, or `failed`.
                    */
                status: string;
                /**
                    * HTTP request method type.
                    */
                requestMethod: string;
                /**
                    * HTTP request path and query.
                    */
                requestPath: string;
                /**
                    * HTTP response headers as a key-value object. This will return only whitelisted headers. All headers are returned if execution is created as synchronous.
                    */
                requestHeaders: Headers[];
                /**
                    * HTTP response status code.
                    */
                responseStatusCode: number;
                /**
                    * HTTP response body. This will return empty unless execution is created as synchronous.
                    */
                responseBody: string;
                /**
                    * HTTP response headers as a key-value object. This will return only whitelisted headers. All headers are returned if execution is created as synchronous.
                    */
                responseHeaders: Headers[];
                /**
                    * Function logs. Includes the last 4,000 characters. This will return an empty string unless the response is returned using an API key or as part of a webhook payload.
                    */
                logs: string;
                /**
                    * Function errors. Includes the last 4,000 characters. This will return an empty string unless the response is returned using an API key or as part of a webhook payload.
                    */
                errors: string;
                /**
                    * Function execution duration in seconds.
                    */
                duration: number;
                /**
                    * The scheduled time for execution. If left empty, execution will be queued immediately.
                    */
                scheduledAt?: string;
        };
        /**
            * Build
            */
        type Build = {
                /**
                    * Build ID.
                    */
                $id: string;
                /**
                    * The deployment that created this build.
                    */
                deploymentId: string;
                /**
                    * The build status. There are a few different types and each one means something different. \nFailed - The deployment build has failed. More details can usually be found in buildStderr\nReady - The deployment build was successful and the deployment is ready to be deployed\nProcessing - The deployment is currently waiting to have a build triggered\nBuilding - The deployment is currently being built
                    */
                status: string;
                /**
                    * The stdout of the build.
                    */
                stdout: string;
                /**
                    * The stderr of the build.
                    */
                stderr: string;
                /**
                    * The deployment creation date in ISO 8601 format.
                    */
                startTime: string;
                /**
                    * The time the build was finished in ISO 8601 format.
                    */
                endTime: string;
                /**
                    * The build duration in seconds.
                    */
                duration: number;
                /**
                    * The code size in bytes.
                    */
                size: number;
        };
        /**
            * Project
            */
        type Project = {
                /**
                    * Project ID.
                    */
                $id: string;
                /**
                    * Project creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Project update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Project name.
                    */
                name: string;
                /**
                    * Project description.
                    */
                description: string;
                /**
                    * Project team ID.
                    */
                teamId: string;
                /**
                    * Project logo file ID.
                    */
                logo: string;
                /**
                    * Project website URL.
                    */
                url: string;
                /**
                    * Company legal name.
                    */
                legalName: string;
                /**
                    * Country code in [ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1) two-character format.
                    */
                legalCountry: string;
                /**
                    * State name.
                    */
                legalState: string;
                /**
                    * City name.
                    */
                legalCity: string;
                /**
                    * Company Address.
                    */
                legalAddress: string;
                /**
                    * Company Tax ID.
                    */
                legalTaxId: string;
                /**
                    * Session duration in seconds.
                    */
                authDuration: number;
                /**
                    * Max users allowed. 0 is unlimited.
                    */
                authLimit: number;
                /**
                    * Max sessions allowed per user. 100 maximum.
                    */
                authSessionsLimit: number;
                /**
                    * Max allowed passwords in the history list per user. Max passwords limit allowed in history is 20. Use 0 for disabling password history.
                    */
                authPasswordHistory: number;
                /**
                    * Whether or not to check user&#039;s password against most commonly used passwords.
                    */
                authPasswordDictionary: boolean;
                /**
                    * Whether or not to check the user password for similarity with their personal data.
                    */
                authPersonalDataCheck: boolean;
                /**
                    * An array of mock numbers and their corresponding verification codes (OTPs).
                    */
                authMockNumbers: MockNumber[];
                /**
                    * Whether or not to send session alert emails to users.
                    */
                authSessionAlerts: boolean;
                /**
                    * List of Auth Providers.
                    */
                oAuthProviders: AuthProvider[];
                /**
                    * List of Platforms.
                    */
                platforms: Platform[];
                /**
                    * List of Webhooks.
                    */
                webhooks: Webhook[];
                /**
                    * List of API Keys.
                    */
                keys: Key[];
                /**
                    * Status for custom SMTP
                    */
                smtpEnabled: boolean;
                /**
                    * SMTP sender name
                    */
                smtpSenderName: string;
                /**
                    * SMTP sender email
                    */
                smtpSenderEmail: string;
                /**
                    * SMTP reply to email
                    */
                smtpReplyTo: string;
                /**
                    * SMTP server host name
                    */
                smtpHost: string;
                /**
                    * SMTP server port
                    */
                smtpPort: number;
                /**
                    * SMTP server username
                    */
                smtpUsername: string;
                /**
                    * SMTP server password
                    */
                smtpPassword: string;
                /**
                    * SMTP server secure protocol
                    */
                smtpSecure: string;
                /**
                    * Email/Password auth method status
                    */
                authEmailPassword: boolean;
                /**
                    * Magic URL auth method status
                    */
                authUsersAuthMagicURL: boolean;
                /**
                    * Email (OTP) auth method status
                    */
                authEmailOtp: boolean;
                /**
                    * Anonymous auth method status
                    */
                authAnonymous: boolean;
                /**
                    * Invites auth method status
                    */
                authInvites: boolean;
                /**
                    * JWT auth method status
                    */
                authJWT: boolean;
                /**
                    * Phone auth method status
                    */
                authPhone: boolean;
                /**
                    * Account service status
                    */
                serviceStatusForAccount: boolean;
                /**
                    * Avatars service status
                    */
                serviceStatusForAvatars: boolean;
                /**
                    * Databases service status
                    */
                serviceStatusForDatabases: boolean;
                /**
                    * Locale service status
                    */
                serviceStatusForLocale: boolean;
                /**
                    * Health service status
                    */
                serviceStatusForHealth: boolean;
                /**
                    * Storage service status
                    */
                serviceStatusForStorage: boolean;
                /**
                    * Teams service status
                    */
                serviceStatusForTeams: boolean;
                /**
                    * Users service status
                    */
                serviceStatusForUsers: boolean;
                /**
                    * Functions service status
                    */
                serviceStatusForFunctions: boolean;
                /**
                    * GraphQL service status
                    */
                serviceStatusForGraphql: boolean;
                /**
                    * Messaging service status
                    */
                serviceStatusForMessaging: boolean;
        };
        /**
            * Webhook
            */
        type Webhook = {
                /**
                    * Webhook ID.
                    */
                $id: string;
                /**
                    * Webhook creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Webhook update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Webhook name.
                    */
                name: string;
                /**
                    * Webhook URL endpoint.
                    */
                url: string;
                /**
                    * Webhook trigger events.
                    */
                events: string[];
                /**
                    * Indicated if SSL / TLS Certificate verification is enabled.
                    */
                security: boolean;
                /**
                    * HTTP basic authentication username.
                    */
                httpUser: string;
                /**
                    * HTTP basic authentication password.
                    */
                httpPass: string;
                /**
                    * Signature key which can be used to validated incoming
                    */
                signatureKey: string;
                /**
                    * Indicates if this webhook is enabled.
                    */
                enabled: boolean;
                /**
                    * Webhook error logs from the most recent failure.
                    */
                logs: string;
                /**
                    * Number of consecutive failed webhook attempts.
                    */
                attempts: number;
        };
        /**
            * Key
            */
        type Key = {
                /**
                    * Key ID.
                    */
                $id: string;
                /**
                    * Key creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Key update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Key name.
                    */
                name: string;
                /**
                    * Key expiration date in ISO 8601 format.
                    */
                expire: string;
                /**
                    * Allowed permission scopes.
                    */
                scopes: string[];
                /**
                    * Secret key.
                    */
                secret: string;
                /**
                    * Most recent access date in ISO 8601 format. This attribute is only updated again after 24 hours.
                    */
                accessedAt: string;
                /**
                    * List of SDK user agents that used this key.
                    */
                sdks: string[];
        };
        /**
            * Mock Number
            */
        type MockNumber = {
                /**
                    * Mock phone number for testing phone authentication. Useful for testing phone authentication without sending an SMS.
                    */
                phone: string;
                /**
                    * Mock OTP for the number.
                    */
                otp: string;
        };
        /**
            * AuthProvider
            */
        type AuthProvider = {
                /**
                    * Auth Provider.
                    */
                key: string;
                /**
                    * Auth Provider name.
                    */
                name: string;
                /**
                    * OAuth 2.0 application ID.
                    */
                appId: string;
                /**
                    * OAuth 2.0 application secret. Might be JSON string if provider requires extra configuration.
                    */
                secret: string;
                /**
                    * Auth Provider is active and can be used to create session.
                    */
                enabled: boolean;
        };
        /**
            * Platform
            */
        type Platform = {
                /**
                    * Platform ID.
                    */
                $id: string;
                /**
                    * Platform creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Platform update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Platform name.
                    */
                name: string;
                /**
                    * Platform type. Possible values are: web, flutter-web, flutter-ios, flutter-android, ios, android, and unity.
                    */
                type: string;
                /**
                    * Platform Key. iOS bundle ID or Android package name.  Empty string for other platforms.
                    */
                key: string;
                /**
                    * App store or Google Play store ID.
                    */
                store: string;
                /**
                    * Web app hostname. Empty string for other platforms.
                    */
                hostname: string;
                /**
                    * HTTP basic authentication username.
                    */
                httpUser: string;
                /**
                    * HTTP basic authentication password.
                    */
                httpPass: string;
        };
        /**
            * Variable
            */
        type Variable = {
                /**
                    * Variable ID.
                    */
                $id: string;
                /**
                    * Variable creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Variable creation date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Variable key.
                    */
                key: string;
                /**
                    * Variable value.
                    */
                value: string;
                /**
                    * Service to which the variable belongs. Possible values are &quot;project&quot;, &quot;function&quot;
                    */
                resourceType: string;
                /**
                    * ID of resource to which the variable belongs. If resourceType is &quot;project&quot;, it is empty. If resourceType is &quot;function&quot;, it is ID of the function.
                    */
                resourceId: string;
        };
        /**
            * Country
            */
        type Country = {
                /**
                    * Country name.
                    */
                name: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                code: string;
        };
        /**
            * Continent
            */
        type Continent = {
                /**
                    * Continent name.
                    */
                name: string;
                /**
                    * Continent two letter code.
                    */
                code: string;
        };
        /**
            * Language
            */
        type Language = {
                /**
                    * Language name.
                    */
                name: string;
                /**
                    * Language two-character ISO 639-1 codes.
                    */
                code: string;
                /**
                    * Language native name.
                    */
                nativeName: string;
        };
        /**
            * Currency
            */
        type Currency = {
                /**
                    * Currency symbol.
                    */
                symbol: string;
                /**
                    * Currency name.
                    */
                name: string;
                /**
                    * Currency native symbol.
                    */
                symbolNative: string;
                /**
                    * Number of decimal digits.
                    */
                decimalDigits: number;
                /**
                    * Currency digit rounding.
                    */
                rounding: number;
                /**
                    * Currency code in [ISO 4217-1](http://en.wikipedia.org/wiki/ISO_4217) three-character format.
                    */
                code: string;
                /**
                    * Currency plural name
                    */
                namePlural: string;
        };
        /**
            * Phone
            */
        type Phone = {
                /**
                    * Phone code.
                    */
                code: string;
                /**
                    * Country two-character ISO 3166-1 alpha code.
                    */
                countryCode: string;
                /**
                    * Country name.
                    */
                countryName: string;
        };
        /**
            * Health Antivirus
            */
        type HealthAntivirus = {
                /**
                    * Antivirus version.
                    */
                version: string;
                /**
                    * Antivirus status. Possible values can are: `disabled`, `offline`, `online`
                    */
                status: string;
        };
        /**
            * Health Queue
            */
        type HealthQueue = {
                /**
                    * Amount of actions in the queue.
                    */
                size: number;
        };
        /**
            * Health Status
            */
        type HealthStatus = {
                /**
                    * Name of the service.
                    */
                name: string;
                /**
                    * Duration in milliseconds how long the health check took.
                    */
                ping: number;
                /**
                    * Service status. Possible values can are: `pass`, `fail`
                    */
                status: string;
        };
        /**
            * Health Certificate
            */
        type HealthCertificate = {
                /**
                    * Certificate name
                    */
                name: string;
                /**
                    * Subject SN
                    */
                subjectSN: string;
                /**
                    * Issuer organisation
                    */
                issuerOrganisation: string;
                /**
                    * Valid from
                    */
                validFrom: string;
                /**
                    * Valid to
                    */
                validTo: string;
                /**
                    * Signature type SN
                    */
                signatureTypeSN: string;
        };
        /**
            * Health Time
            */
        type HealthTime = {
                /**
                    * Current unix timestamp on trustful remote server.
                    */
                remoteTime: number;
                /**
                    * Current unix timestamp of local server where Appconda runs.
                    */
                localTime: number;
                /**
                    * Difference of unix remote and local timestamps in milliseconds.
                    */
                diff: number;
        };
        /**
            * Metric
            */
        type Metric = {
                /**
                    * The value of this metric at the timestamp.
                    */
                value: number;
                /**
                    * The date at which this metric was aggregated in ISO 8601 format.
                    */
                date: string;
        };
        /**
            * Metric Breakdown
            */
        type MetricBreakdown = {
                /**
                    * Resource ID.
                    */
                resourceId: string;
                /**
                    * Resource name.
                    */
                name: string;
                /**
                    * The value of this metric at the timestamp.
                    */
                value: number;
        };
        /**
            * UsageDatabases
            */
        type UsageDatabases = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of databases.
                    */
                databasesTotal: number;
                /**
                    * Total aggregated number  of collections.
                    */
                collectionsTotal: number;
                /**
                    * Total aggregated number of documents.
                    */
                documentsTotal: number;
                /**
                    * Aggregated number of databases per period.
                    */
                databases: Metric[];
                /**
                    * Aggregated number of collections per period.
                    */
                collections: Metric[];
                /**
                    * Aggregated number of documents per period.
                    */
                documents: Metric[];
        };
        /**
            * UsageDatabase
            */
        type UsageDatabase = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of collections.
                    */
                collectionsTotal: number;
                /**
                    * Total aggregated number of documents.
                    */
                documentsTotal: number;
                /**
                    * Aggregated  number of collections per period.
                    */
                collections: Metric[];
                /**
                    * Aggregated  number of documents per period.
                    */
                documents: Metric[];
        };
        /**
            * UsageCollection
            */
        type UsageCollection = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of of documents.
                    */
                documentsTotal: number;
                /**
                    * Aggregated  number of documents per period.
                    */
                documents: Metric[];
        };
        /**
            * UsageUsers
            */
        type UsageUsers = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of statistics of users.
                    */
                usersTotal: number;
                /**
                    * Total aggregated number of active sessions.
                    */
                sessionsTotal: number;
                /**
                    * Aggregated number of users per period.
                    */
                users: Metric[];
                /**
                    * Aggregated number of active sessions  per period.
                    */
                sessions: Metric[];
        };
        /**
            * StorageUsage
            */
        type UsageStorage = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of buckets
                    */
                bucketsTotal: number;
                /**
                    * Total aggregated number of files.
                    */
                filesTotal: number;
                /**
                    * Total aggregated number of files storage (in bytes).
                    */
                filesStorageTotal: number;
                /**
                    * Aggregated number of buckets per period.
                    */
                buckets: Metric[];
                /**
                    * Aggregated number of files per period.
                    */
                files: Metric[];
                /**
                    * Aggregated number of files storage (in bytes) per period .
                    */
                storage: Metric[];
        };
        /**
            * UsageBuckets
            */
        type UsageBuckets = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of bucket files.
                    */
                filesTotal: number;
                /**
                    * Total aggregated number of bucket files storage (in bytes).
                    */
                filesStorageTotal: number;
                /**
                    * Aggregated  number of bucket files per period.
                    */
                files: Metric[];
                /**
                    * Aggregated  number of bucket storage files (in bytes) per period.
                    */
                storage: Metric[];
        };
        /**
            * UsageFunctions
            */
        type UsageFunctions = {
                /**
                    * Time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of functions.
                    */
                functionsTotal: number;
                /**
                    * Total aggregated number of functions deployments.
                    */
                deploymentsTotal: number;
                /**
                    * Total aggregated sum of functions deployment storage.
                    */
                deploymentsStorageTotal: number;
                /**
                    * Total aggregated number of functions build.
                    */
                buildsTotal: number;
                /**
                    * total aggregated sum of functions build storage.
                    */
                buildsStorageTotal: number;
                /**
                    * Total aggregated sum of functions build compute time.
                    */
                buildsTimeTotal: number;
                /**
                    * Total aggregated sum of functions build mbSeconds.
                    */
                buildsMbSecondsTotal: number;
                /**
                    * Total  aggregated number of functions execution.
                    */
                executionsTotal: number;
                /**
                    * Total aggregated sum of functions  execution compute time.
                    */
                executionsTimeTotal: number;
                /**
                    * Total aggregated sum of functions execution mbSeconds.
                    */
                executionsMbSecondsTotal: number;
                /**
                    * Aggregated number of functions per period.
                    */
                functions: Metric[];
                /**
                    * Aggregated number of functions deployment per period.
                    */
                deployments: Metric[];
                /**
                    * Aggregated number of  functions deployment storage per period.
                    */
                deploymentsStorage: Metric[];
                /**
                    * Aggregated number of functions build per period.
                    */
                builds: Metric[];
                /**
                    * Aggregated sum of functions build storage per period.
                    */
                buildsStorage: Metric[];
                /**
                    * Aggregated sum of  functions build compute time per period.
                    */
                buildsTime: Metric[];
                /**
                    * Aggregated sum of functions build mbSeconds per period.
                    */
                buildsMbSeconds: Metric[];
                /**
                    * Aggregated number of  functions execution per period.
                    */
                executions: Metric[];
                /**
                    * Aggregated number of functions execution compute time per period.
                    */
                executionsTime: Metric[];
                /**
                    * Aggregated number of functions mbSeconds per period.
                    */
                executionsMbSeconds: Metric[];
        };
        /**
            * UsageFunction
            */
        type UsageFunction = {
                /**
                    * The time range of the usage stats.
                    */
                range: string;
                /**
                    * Total aggregated number of function deployments.
                    */
                deploymentsTotal: number;
                /**
                    * Total aggregated sum of function deployments storage.
                    */
                deploymentsStorageTotal: number;
                /**
                    * Total aggregated number of function builds.
                    */
                buildsTotal: number;
                /**
                    * total aggregated sum of function builds storage.
                    */
                buildsStorageTotal: number;
                /**
                    * Total aggregated sum of function builds compute time.
                    */
                buildsTimeTotal: number;
                /**
                    * Total aggregated sum of function builds mbSeconds.
                    */
                buildsMbSecondsTotal: number;
                /**
                    * Total  aggregated number of function executions.
                    */
                executionsTotal: number;
                /**
                    * Total aggregated sum of function  executions compute time.
                    */
                executionsTimeTotal: number;
                /**
                    * Total aggregated sum of function executions mbSeconds.
                    */
                executionsMbSecondsTotal: number;
                /**
                    * Aggregated number of function deployments per period.
                    */
                deployments: Metric[];
                /**
                    * Aggregated number of  function deployments storage per period.
                    */
                deploymentsStorage: Metric[];
                /**
                    * Aggregated number of function builds per period.
                    */
                builds: Metric[];
                /**
                    * Aggregated sum of function builds storage per period.
                    */
                buildsStorage: Metric[];
                /**
                    * Aggregated sum of function builds compute time per period.
                    */
                buildsTime: Metric[];
                /**
                    * Aggregated number of function builds mbSeconds per period.
                    */
                buildsMbSeconds: Metric[];
                /**
                    * Aggregated number of function executions per period.
                    */
                executions: Metric[];
                /**
                    * Aggregated number of function executions compute time per period.
                    */
                executionsTime: Metric[];
                /**
                    * Aggregated number of function mbSeconds per period.
                    */
                executionsMbSeconds: Metric[];
        };
        /**
            * UsageProject
            */
        type UsageProject = {
                /**
                    * Total aggregated number of function executions.
                    */
                executionsTotal: number;
                /**
                    * Total aggregated  number of documents.
                    */
                documentsTotal: number;
                /**
                    * Total aggregated number of databases.
                    */
                databasesTotal: number;
                /**
                    * Total aggregated number of users.
                    */
                usersTotal: number;
                /**
                    * Total aggregated sum of files storage size (in bytes).
                    */
                filesStorageTotal: number;
                /**
                    * Total aggregated sum of deployments storage size (in bytes).
                    */
                deploymentsStorageTotal: number;
                /**
                    * Total aggregated number of buckets.
                    */
                bucketsTotal: number;
                /**
                    * Total aggregated number of function executions mbSeconds.
                    */
                executionsMbSecondsTotal: number;
                /**
                    * Total aggregated number of function builds mbSeconds.
                    */
                buildsMbSecondsTotal: number;
                /**
                    * Aggregated  number of requests per period.
                    */
                requests: Metric[];
                /**
                    * Aggregated number of consumed bandwidth per period.
                    */
                network: Metric[];
                /**
                    * Aggregated number of users per period.
                    */
                users: Metric[];
                /**
                    * Aggregated number of executions per period.
                    */
                executions: Metric[];
                /**
                    * Aggregated breakdown in totals of executions by functions.
                    */
                executionsBreakdown: MetricBreakdown[];
                /**
                    * Aggregated breakdown in totals of usage by buckets.
                    */
                bucketsBreakdown: MetricBreakdown[];
                /**
                    * Aggregated breakdown in totals of execution mbSeconds by functions.
                    */
                executionsMbSecondsBreakdown: MetricBreakdown[];
                /**
                    * Aggregated breakdown in totals of build mbSeconds by functions.
                    */
                buildsMbSecondsBreakdown: MetricBreakdown[];
                /**
                    * Aggregated breakdown in totals of deployments storage size (in bytes).
                    */
                deploymentsStorageBreakdown: MetricBreakdown[];
        };
        /**
            * Headers
            */
        type Headers = {
                /**
                    * Header name.
                    */
                name: string;
                /**
                    * Header value.
                    */
                value: string;
        };
        /**
            * Specification
            */
        type Specification = {
                /**
                    * Memory size in MB.
                    */
                memory: number;
                /**
                    * Number of CPUs.
                    */
                cpus: number;
                /**
                    * Is size enabled.
                    */
                enabled: boolean;
                /**
                    * Size slug.
                    */
                slug: string;
        };
        /**
            * Rule
            */
        type ProxyRule = {
                /**
                    * Rule ID.
                    */
                $id: string;
                /**
                    * Rule creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Rule update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Domain name.
                    */
                domain: string;
                /**
                    * Action definition for the rule. Possible values are &quot;api&quot;, &quot;function&quot;, or &quot;redirect&quot;
                    */
                resourceType: string;
                /**
                    * ID of resource for the action type. If resourceType is &quot;api&quot; or &quot;url&quot;, it is empty. If resourceType is &quot;function&quot;, it is ID of the function.
                    */
                resourceId: string;
                /**
                    * Domain verification status. Possible values are &quot;created&quot;, &quot;verifying&quot;, &quot;verified&quot; and &quot;unverified&quot;
                    */
                status: string;
                /**
                    * Certificate generation logs. This will return an empty string if generation did not run, or succeeded.
                    */
                logs: string;
                /**
                    * Certificate auto-renewal date in ISO 8601 format.
                    */
                renewAt: string;
        };
        /**
            * SmsTemplate
            */
        type SmsTemplate = {
                /**
                    * Template type
                    */
                type: string;
                /**
                    * Template locale
                    */
                locale: string;
                /**
                    * Template message
                    */
                message: string;
        };
        /**
            * EmailTemplate
            */
        type EmailTemplate = {
                /**
                    * Template type
                    */
                type: string;
                /**
                    * Template locale
                    */
                locale: string;
                /**
                    * Template message
                    */
                message: string;
                /**
                    * Name of the sender
                    */
                senderName: string;
                /**
                    * Email of the sender
                    */
                senderEmail: string;
                /**
                    * Reply to email address
                    */
                replyTo: string;
                /**
                    * Email subject
                    */
                subject: string;
        };
        /**
            * Console Variables
            */
        type ConsoleVariables = {
                /**
                    * CNAME target for your Appconda custom domains.
                    */
                _APP_DOMAIN_TARGET: string;
                /**
                    * Maximum file size allowed for file upload in bytes.
                    */
                _APP_STORAGE_LIMIT: number;
                /**
                    * Maximum file size allowed for deployment in bytes.
                    */
                _APP_FUNCTIONS_SIZE_LIMIT: number;
                /**
                    * Defines if usage stats are enabled. This value is set to &#039;enabled&#039; by default, to disable the usage stats set the value to &#039;disabled&#039;.
                    */
                _APP_USAGE_STATS: string;
                /**
                    * Defines if VCS (Version Control System) is enabled.
                    */
                _APP_VCS_ENABLED: boolean;
                /**
                    * Defines if main domain is configured. If so, custom domains can be created.
                    */
                _APP_DOMAIN_ENABLED: boolean;
                /**
                    * Defines if AI assistant is enabled.
                    */
                _APP_ASSISTANT_ENABLED: boolean;
        };
        /**
            * MFA Challenge
            */
        type MfaChallenge = {
                /**
                    * Token ID.
                    */
                $id: string;
                /**
                    * Token creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Token expiration date in ISO 8601 format.
                    */
                expire: string;
        };
        /**
            * MFA Recovery Codes
            */
        type MfaRecoveryCodes = {
                /**
                    * Recovery codes.
                    */
                recoveryCodes: string[];
        };
        /**
            * MFAType
            */
        type MfaType = {
                /**
                    * Secret token used for TOTP factor.
                    */
                secret: string;
                /**
                    * URI for authenticator apps.
                    */
                uri: string;
        };
        /**
            * MFAFactors
            */
        type MfaFactors = {
                /**
                    * Can TOTP be used for MFA challenge for this account.
                    */
                totp: boolean;
                /**
                    * Can phone (SMS) be used for MFA challenge for this account.
                    */
                phone: boolean;
                /**
                    * Can email be used for MFA challenge for this account.
                    */
                email: boolean;
                /**
                    * Can recovery code be used for MFA challenge for this account.
                    */
                recoveryCode: boolean;
        };
        /**
            * Provider
            */
        type Provider = {
                /**
                    * Provider ID.
                    */
                $id: string;
                /**
                    * Provider creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Provider update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * The name for the provider instance.
                    */
                name: string;
                /**
                    * The name of the provider service.
                    */
                provider: string;
                /**
                    * Is provider enabled?
                    */
                enabled: boolean;
                /**
                    * Type of provider.
                    */
                type: string;
                /**
                    * Provider credentials.
                    */
                credentials: object;
                /**
                    * Provider options.
                    */
                options?: object;
        };
        /**
            * Message
            */
        type Message = {
                /**
                    * Message ID.
                    */
                $id: string;
                /**
                    * Message creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Message update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Message provider type.
                    */
                providerType: string;
                /**
                    * Topic IDs set as recipients.
                    */
                topics: string[];
                /**
                    * User IDs set as recipients.
                    */
                users: string[];
                /**
                    * Target IDs set as recipients.
                    */
                targets: string[];
                /**
                    * The scheduled time for message.
                    */
                scheduledAt?: string;
                /**
                    * The time when the message was delivered.
                    */
                deliveredAt?: string;
                /**
                    * Delivery errors if any.
                    */
                deliveryErrors?: string[];
                /**
                    * Number of recipients the message was delivered to.
                    */
                deliveredTotal: number;
                /**
                    * Data of the message.
                    */
                data: object;
                /**
                    * Status of delivery.
                    */
                status: string;
        };
        /**
            * Topic
            */
        type Topic = {
                /**
                    * Topic ID.
                    */
                $id: string;
                /**
                    * Topic creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Topic update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * The name of the topic.
                    */
                name: string;
                /**
                    * Total count of email subscribers subscribed to the topic.
                    */
                emailTotal: number;
                /**
                    * Total count of SMS subscribers subscribed to the topic.
                    */
                smsTotal: number;
                /**
                    * Total count of push subscribers subscribed to the topic.
                    */
                pushTotal: number;
                /**
                    * Subscribe permissions.
                    */
                subscribe: string[];
        };
        /**
            * Subscriber
            */
        type Subscriber = {
                /**
                    * Subscriber ID.
                    */
                $id: string;
                /**
                    * Subscriber creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Subscriber update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Target ID.
                    */
                targetId: string;
                /**
                    * Target.
                    */
                target: Target;
                /**
                    * Topic ID.
                    */
                userId: string;
                /**
                    * User Name.
                    */
                userName: string;
                /**
                    * Topic ID.
                    */
                topicId: string;
                /**
                    * The target provider type. Can be one of the following: `email`, `sms` or `push`.
                    */
                providerType: string;
        };
        /**
            * Target
            */
        type Target = {
                /**
                    * Target ID.
                    */
                $id: string;
                /**
                    * Target creation time in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Target update date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Target Name.
                    */
                name: string;
                /**
                    * User ID.
                    */
                userId: string;
                /**
                    * Provider ID.
                    */
                providerId?: string;
                /**
                    * The target provider type. Can be one of the following: `email`, `sms` or `push`.
                    */
                providerType: string;
                /**
                    * The target identifier.
                    */
                identifier: string;
        };
        /**
            * Migration
            */
        type Migration = {
                /**
                    * Migration ID.
                    */
                $id: string;
                /**
                    * Variable creation date in ISO 8601 format.
                    */
                $createdAt: string;
                /**
                    * Variable creation date in ISO 8601 format.
                    */
                $updatedAt: string;
                /**
                    * Migration status ( pending, processing, failed, completed )
                    */
                status: string;
                /**
                    * Migration stage ( init, processing, source-check, destination-check, migrating, finished )
                    */
                stage: string;
                /**
                    * A string containing the type of source of the migration.
                    */
                source: string;
                /**
                    * Resources to migration.
                    */
                resources: string[];
                /**
                    * A group of counters that represent the total progress of the migration.
                    */
                statusCounters: object;
                /**
                    * An array of objects containing the report data of the resources that were migrated.
                    */
                resourceData: object;
                /**
                    * All errors that occurred during the migration process.
                    */
                errors: string[];
        };
        /**
            * Migration Report
            */
        type MigrationReport = {
                /**
                    * Number of users to be migrated.
                    */
                user: number;
                /**
                    * Number of teams to be migrated.
                    */
                team: number;
                /**
                    * Number of databases to be migrated.
                    */
                database: number;
                /**
                    * Number of documents to be migrated.
                    */
                document: number;
                /**
                    * Number of files to be migrated.
                    */
                file: number;
                /**
                    * Number of buckets to be migrated.
                    */
                bucket: number;
                /**
                    * Number of functions to be migrated.
                    */
                function: number;
                /**
                    * Size of files to be migrated in mb.
                    */
                size: number;
                /**
                    * Version of the Appconda instance to be migrated.
                    */
                version: string;
        };
        /**
            * MigrationFirebaseProject
            */
        type FirebaseProject = {
                /**
                    * Project ID.
                    */
                projectId: string;
                /**
                    * Project display name.
                    */
                displayName: string;
        };
}

